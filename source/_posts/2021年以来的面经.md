---
title: 2021年以来的面经
date: 2021-03-02 23:20:07
tags: 
	- 面试
categories: 
	- 面试
---

2021年以来都没有整理面经。一是忙，二是懒，觉得自己失败这么多次不知道是在哪里出问题了。反思了一下，首当其冲的可能还是项目经历问题。自己的项目大多是浅尝辄止，并没有深入了解。例如大一的深度学习，大二的软工、操作系统、暑期交流等，全都没有一个掌握的非常好的，也就导致了在面试的时候自己没有什么可以介绍的，面试官也没有什么可以提问的，非常尴尬。

<!--more-->

腾讯三次一面都没有过，总体来说腾讯更加看重项目经历，面试官会不断地往下挖项目；

字节客户端二面挂，第二次直播后端投递一面过，目前正在二面过程中，字节的流程更加规范，对于项目的要求似乎是低一点，更加注重于考核专业基础知识，比如算法、操作系统、计网、数据库等知识（根据项目经历来提问这些基础知识），个人感觉对没有项目经历的同学更加友好；

深信服两次一面挂，第一次一面是大二下，测开岗，啥也不会，被刷；第二次C++开发岗，面试官问的大多是八股文，但因为当时还没记熟，导致比较结巴，被刷；（面试官面试环境非常差，那边还在施工，背景里还有工人走动）

阿里云计算事业部一面过，还在等二面；但是因为技术栈不符合，被推荐到另一个部门，同时还投了钉钉、CCO事业部，还没面。

- 2021.3.3更新：云计算事业部因为之前的部门(dataworks)偏前端，把我转到了偏后端的事业部，测开岗面了一个半小时，累；然后我跟钉钉事业部的面试官说我不想面了，他说休息几天再面......

华为一面，综测过，主管面不知什么原因，挂；阿里和华为比较看重学校中的成绩，目测成绩高的人申请会比较容易。

其他一些公司：

- 兴业数金，java笔试通过（但我只会C++），由于不想面试，鸽了
- 富途科技（富途牛牛？），后端面试鸽
- ASML，测开，一面后没有消息了
- 多翼，离学校非常近，骑自行车5分钟即可达，但因为公司业务多，暂时没有面试



在面试中也有相当多自己答不出来的问题，现在能想多少是多少吧

# 问题

TODO

主要是自己在操作系统方面给自己挖坑了，导致面试官深入地问。

计网方面自己的实践太少 ，导致也回答不出什么东西。



下面是自己在准备时在网上搜集的一些问题，在面试中命中率也比较高。



# 编译过程

C++ 程序的编译过程（源码如何转化成二进制）

参考链接： [🔗 这里](https://blog.csdn.net/u012662731/article/details/78520349)。

编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接

- 编译预处理：处理以 # 开头的指令

- 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码

- 汇编：将汇编代码 .s 翻译成机器指令 .o 文件

- 链接：汇编程序生成的目标文件并不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。

	https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dedcb95b-3faa-446e-80de-8a2215d6c9f9/1606736873-ansXlT-file_1606736876671

链接分为两种： 参考链接： [🔗 这里](https://www.cnblogs.com/cyyljw/p/10949660.html)

- 静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中
- 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间

二者的优缺点：

- 静态链接 **浪费空间**，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（**更新困难**）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容
- 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。

## 1. 指针和引用的区别

- 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）
- 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（是否占内存）
- 指针可以为空，但是引用必须绑定对象（是否可为空）
- 指针可以有多级，但是引用只能一级（是否能为多级）

## 2. 堆和栈的区别

- 申请方式：栈是系统自动分配，堆是程序员主动申请
- 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上
- 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的
- 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片
- 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制

## 3. new 和 delete 是如何实现的，new 与 malloc 的异同处

在使用的时候 new,delete 搭配使用，malloc 和 free 搭配使用。

- 属性：malloc/free 是库函数，需要头文件的支持；new/delete 是关键字，需要编译器的支持
- 参数：new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小
- 返回值：new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，符合类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针
- 分配失败：new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针
- 重载：new/delete 支持重载，malloc/free 不能进行重载
- 自定义类型实现：new 首先调用 operator new 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete 释放空间（底层通过 free 实现）。malloc/free 无法进行自定义类型的对象的构造和析构
- 内存区域：new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

## 4. C 和 C++ 的区别

- C 是面向过程的编程，特点是函数；C++ 是面向对象的编程，特点是类。（特性）
- C 主要用在嵌入式开发、驱动开发和硬件直接打交道的领域；C++ 可以用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。（应用领域）
- C++ 继承了C的底层操作特性，增加了面向对象的机制，增加了泛型编程、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。（相较于 C 的升级）

## 5. C++、Java 的联系与区别，包括语言特性、垃圾回收、应用场景等（java 的垃圾回收机制）

[参考链接](https://blog.csdn.net/hustcqb/article/details/11771679) 二者在语言特性上有很大的区别：

- 指针：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；JAVA 并不是没有指针，虚拟机(JVM)内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 JAVA 增加了内存管理机制
- 多重继承：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；JAVA 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便
- 数据类型和类：C++ 可以将变量或函数定义成全局，但是JAVA是完全面向对象的语言，除了基本的数据类型之外，其他的都作为类的对象，包括数组。

垃圾回收：

- JAVA 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存
- JAVA 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，JAVA 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 JAVA 中的内存回收是以线程的方式在后台运行的，利用空闲时间。

应用场景：

- java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持，
- C++ 可以直接编译成可执行文件，运行效率比 JAVA 高
- JAVA 主要用来开发 web 应用
- C++ 主要用在嵌入式开发、网络、并发编程的方面

## 6. Struct 和 class 的区别

struct 和 class 都可以自定义数据类型，也支持继承操作

- struct 中默认的访问级别是 public，默认的继承级别也是 public
- class 中默认的访问级别是 private，默认的继承级别也是 private
- 当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于继承的是 class(public) 还是 struct(private)
- class 可以定义模板参数，struct 也可以

# **[struct和union区别](https://www.cnblogs.com/kevin-lb/p/10008887.html)**

主要区别有以下几点：

1、在存储多个成员信息时，编译器会自动非是投入出题人每个成员分配存储空间，struct可以存储多个成员变量信息；而union每个成员会共用同一个存储空间，且只能存储最后一个成员的信息；

2、都是由多个不同的数据类型成员组成，但在任何同一时刻，union值存放了一个被先选中的成员，而结构体struct的所有成员都存在；

3、对于union的不同成员赋值，将会对其他成员重写，原来的成员值就不存在了，而对struct的不同成员赋值是互不影响的；

4、系统分配给union的内存size就是size最大的成员所需空间大小，struct在分配空间时，根据成员类型不同，会存在字节对齐情况，具体对齐标准和机器有关，可能是4字节或8字节等对齐方式。

## 7. define 和 const 的区别（编译阶段、安全性、内存占用等）

- 编译阶段：define 是在编译预处理阶段起作用，const 是在编译阶段和程序运行阶段起作用
- 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的只读变量是有类型的，是要进行判断的，可以避免一些低级的错误
- 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const 定义的只读变量在程序运行过程中只有一份
- 调试：define 定义的不能调试，因为在预编译阶段就已经进行替换了；const 定义的可以进行调试

const 的优点：

- 有数据类型，在定义式可进行安全性检查
- 可调式
- 占用较少的空间

## 8. 在 C++ 中 const 和 static 的用法（定义，用途）

const 参考 [🔗 这里](https://blog.csdn.net/Eric_Jo/article/details/4138548?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)。

- const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率
- const 修饰函数参数，使得传递过来的函数参数的值不能改变
- const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外，函数参数也除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量

static 定义静态变量，静态函数

- static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间
- static 作用于全局变量和函数，改变了全局变量的作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性
- static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数

## 9. const 和 static 在类中使用的注意事项（定义、初始化和使用）

参考 [🔗 这里](https://www.runoob.com/w3cnote/cpp-static-const.html)。

**static 静态成员变量：**

1. 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private/public/protected 访问规则。
2. 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。
3. 静态成员变量可以作为成员函数的参数可选参数，而普通成员变量不可以

```
class base{ 
public : 
    static int _staticVar; 
    int _var; 
    void foo1(int i=_staticVar);//正确,_staticVar为静态数据成员 
    void foo2(int i=_var);//错误,_var为普通数据成员 
};
```

1. 静态数据成员的类型可以是所属类的类型，而普通数据成员不可以，普通数据成员只可能声明成类的指针或引用

```
class base{ 
public : 
    static base _object1;//正确，静态数据成员 
    base _object2;//错误 
    base *pObject;//正确，指针 
    base &mObject;//正确，引用 
};
```

**static 静态成员函数：**

1. 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数
2. 静态成员函数不能声明成虚函数（virtual）、const、volatile

**const 成员变量**

1. const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化
2. const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的，所以不能在类的声明中初始化 const 成员变量，因为类的对象还没有创建，编译器不知道他的值

**const 成员函数**

1. 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量
2. 不能调用非常量成员函数，以防修改成员变量的值

**const static** 如果要想成员变量在整个类中都是恒定的常量，应该用类的枚举常量或者 static const. 在类中进行声明，在类外进行初始化（类似于类的静态常量）

## 10. C++ 中的 const 类成员函数（用法和意义）

用法：如上 意义：防止修改成员变量

## （11）计算下面几个类的大小：

参考链接：[🔗 这里](https://blog.csdn.net/fengxinlinux/article/details/72836199)

类本身没有大小，这里类的大小是指：类对象所占的大小。

- 类的大小遵循结构体的对齐规则
- 类的大小与普通成员函数和静态成员无关（包括：普通成员函数、静态成员函数、静态数据成员、静态常量数据成员），与普通数据成员有关
- 虚函数对类的大小有影响，是因为虚函数指针的影响
- 虚继承对类的大小有影响，是因为虚基表指针带来的影响
- 空类的大小是 1

```cpp
#include <bits/stdc++.h>
using namespace std;

class A{
    //静态成员
    static int a;
    const static int b;    
    static int fun1(){}

    //普通成员函数
    void fun(){}
};

//普通数据成员
class B{
    int a;    
};

//虚函数
class C{
    virtual int fun(){}
};

//结构体对齐原则
class D{
    int a;
    virtual int fun(){}
};
int main(){
    cout << sizeof(A) << endl;//1
    cout << sizeof(B) << endl;//4:表示一个整型变量的大小
    cout << sizeof(C) << endl;//8：虚函数表的指针的大小
    cout << sizeof(D) << endl;//16：整型变量的大小+虚函数指针的大小+对齐原则（4）
    return 0;
}
```

## （12）给一个代码，求输出结果

```cpp
class A
{
public:
	A(int x){}
};
```

问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？， 这里会进行隐式转化 A a(1).implicit 正确

这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，例子很多，不多说了）

## （13）C++的STL介绍

（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等，笔者也整理过STL相关的面经，有兴趣的可以自行查阅

## （14）STL 源码中的 hash 表的实现

hashtable 是采用开链法来完成的，（vector + list）

- 底层键值序列采用 vector 实现，vector 的大小取的是质数，且相邻质数的大小约为 2 倍关系，当创建 hashtable 时，会自动选取一个接近所创建大小的质数作为当前 hashtable 的大小；
- 对应键的值序列采用单向 list 实现；
- 当 hashtable 的键 vector 的大小重新分配的时候，原键的值 list 也会重新分配，因为 vector 重建了相当于键增加了，那么原来的值对应的键可能就不同于原来分配的键，这样就需要重新确定值的键。

## （15）STL 中 unordered_map 和 map 的区别

- 底层实现不同： unordered_map 底层实现是一个哈希表，元素无序 map 底层实现是红黑树，其内部所有的元素都是有序的，因此对 map 的所有操作，其实都是对红黑树的操作
- 优缺点：
	- unordered_map：查找效率高；但是建立哈希表比较耗费时间
	- map：内部元素有序，查找和删除操作都是 logn 的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间
- 适用情况： 对于要求内部元素有序的使用 map，对于要求查找效率的用 unordered_map

## （16）STL 中 vector 的实现

vector 是一个动态数组，底层实现是一段连续的线性内存空间。 扩容的本质：当 vector 实际所占用的内存空间和容量相等时，如果再往其中添加元素需要进行扩容。其步骤如下：

- 首先，申请一块更大的存储空间，一般是增加当前容量的 50% 或者 100%，和编译器有关；
- 然后，将旧内存空间的内容，按照原来的顺序放到新的空间中
- 最后，将旧内存空间的内容释放掉，本质上其存储空间不会释放，只是删除了里面的内容。

从 vector 扩容的原理也可以看出：vector 容器释放后，与其相关的指针、引用以及迭代器会失效的原因。

## （17）vector 使用的注意点及其原因，频繁对 vector 调用 push_back() 对性能的影响和原因

主要是在插入元素方面：插入元素需要考虑元素的移动问题和是否需要扩容的问题 频繁的调用 push_back() 也是扩容的问题对性能的影响

## （18）C++ 中的重载和重写(覆盖)的区别：

- 对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间，子类和父类之间
- 重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰
- virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有

## （19）C++ 内存管理（热门问题，问过）

参考：[🔗 这里](https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368) C++ 内存分区：栈、堆、自由存储区、全局/静态存储区、常量区

- 栈：存放函数的局部变量，由编译器自动分配和释放
- 堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收
- 自由存储区：和堆十分相似，存放由 new 分配的内存块，由 delete 释放内存
- 全局区/静态区：存放全局变量和静态变量
- 常量存储区：存放的是常量，不允许修改

堆和自由存储区的区别： 参考链接：[🔗 这里](https://www.cnblogs.com/qg-whz/p/5060894.html)

- 自由存储是 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存
- new 所申请的内存区域在 C++ 中成为自由存储区。藉由堆实现的自由存储，可以说 new 所申请的内存区域在堆上
- 堆和自由存储区有区别，并非等价。使用 new 来分配内存，程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。

指针和数组的对比：

1. 字符数组的内容可以改变，字符指针的内容不可以改变

```cpp
char a[] = "hello";
a[0] = 'l';
cout << a << endl;
char *p = "world";//p指向常量字符串
p[0] = 'h'; //运行出错
```

1. 字符数组之间不能赋值，不能直接用比较运算符直接比较，若进行赋值调用 strcpy() 函数，若进行比较调用 strcmp() 函数；

```cpp
char a[] = "hello";
char b[10];
strcpy(b, a);//不能用b = a;
if(strcmp(a, b) == 0)//不能用a==b
	cout << "endl";
```

1. 运算符 sizeof 可以计算出字符数组的容量，但是计算字符指针时，得到的是指针变量所占用的空间，而不是指针所指向空间的大小。

```cpp
char a[] = "hello";
char *p = a;
cout << sizeof a << endl;//6字节
cout << sizeof p << endl;//8字节（64位）
```

但是当数组作为参数传递时，数组会自动退化为指针

```cpp
void fun(char a[100]){
	cout << sizeof a << endl;//结果是8（64位）
}
```

**调用函数申请空间**

1. 指针作为函数的参数传递：

```cpp
void GetMemory(char *p, int num)
{
　p = (char *)malloc(sizeof(char) * num);
}

void Test(void)
{
　char *str = NULL;
　GetMemory(str, 100); // str 仍然为 NULL
　strcpy(str, "hello"); // 运行错误
}
```

上述程序出错的原因在于：调用函数时，传递的是变量的值“值传递”，在 GetMemory 函数内部改变的是参数 p 的副本，并不会影响参数 p 本身，也就是说 str 并没有获得内存。这样程序最终会导致内存泄漏，调用 GetMemory 函数多少次，就会出现多少次内存泄漏，因为在函数内部只动态申请了内存，并没有用 free 释放掉动态内存空间。

如果想要通过这种方式申请空间，将 GetMemory 函数的形参改为“指向指针的指针”

```cpp
void GetMemory2(char **p, int num)
{
　*p = (char *)malloc(sizeof(char) * num);
}
void Test2(void)
{
　char *str = NULL;
　GetMemory2(&str, 100); // 注意参数是 &str，而不是str
　strcpy(str, "hello");
　cout<< str << endl;
　free(str);//特别注意：这里是将动态申请的内存空间释放掉
}
```

1. 用函数的返回值来传递动态申请的内存空间

```cpp
char *GetString(void)
{
　char p[] = "hello world";
　return p; // 编译器将提出警告：将局部变量返回
}
void Test4(void)
{
　char *str = NULL;
　str = GetString(); // str 的内容是垃圾
　cout<< str << endl;
}
char *GetString2(void)
{
　char *p = "hello world";
　return p;//编译器给出警告：将string const转化成 char*
}
void Test5(void)
{
　char *str = NULL;
　str = GetString2();
　cout<< str << endl;
}
```

**在一个函数中如何返回一个变量的指针？** 对于普通变量而言，是存储在栈内存中，当函数调用完毕后，栈内存的空间会被释放，如果返回局部变量的指针，回到主调函数后，该指针是悬挂指针指向垃圾内存，如何来处理这种情况呢？

可以返回存储在堆内存或者全局区的变量的指针：

- 返回静态类型对象的指针，会导致占用大量的内存空间
- 返回存放在堆上的对象的指针，该对象所在的内存空间由用户控制什么时候释放，那如何知道什么时候释放合适呢？可以用智能指针来处理，智能指针内部有计数器，当计数器为 0 时，会自动释放该内存。

```cpp
#include <iostream>
using namespace std;
 
int func1(int param)
{
 int local_param = param;
 
 return local_param;
}

//返回静态变量的地址 
int* func2(int param)
{
 static int local_param = param;
 
 return &local_param;
}
 
//返回存放在堆上变量的地址* 
int *func3(int param)
{
 int *new_param = new int(param);
 
 return new_param;
}
 
 
int main()
{
 int *pNewVar = func3(3);
 int *pVar = func2(2);
 
 cout << *pVar << endl;//2
 cout << *pNewVar << endl;//3
 cout << func1(1) << endl;
 
 return 0;
}
```

**出现野指针的情形：**

1. 指针定义的时候未初始化
2. 指针指向动态分配的内存空间在释放（delete 或 free）后，未置为 NULL，让人误以为是合法指针
3. 指针操作超过了变量的作用范围。例如：在函数中将一个局部变量的地址作为函数的返回值，这里编译器会给出警告，因为离开该函数后，局部变量的空间就会释放掉，返回的地址（指针）相当于是野指针。

**深拷贝和浅拷贝带来的问题：** 类中默认的拷贝构造函数和赋值构造函数都是浅拷贝，当类的成员变量中出现指针变量时，最好使用深拷贝，避免内存空间多次释放的问题出现。

**内存泄漏：** 内存泄漏常指的是堆内存泄漏，当然还包括系统资源的泄漏

参考链接：[🔗 这里](https://blog.csdn.net/bl520025/article/details/8967648)**野指针：** 指针指向的内存空间已经释放掉**悬挂指针：** 指针指向的内存空间由于中间改变了其指向，之前的内存空间已无法释放，个人认为是和内存泄漏。 感觉二者并没有什么区别！！！！ 野指针和悬挂指针都是指向垃圾内存的

# 20. **[虚继承、虚函数](https://interview.huihut.com/#/?id=虚继承、虚函数)**

- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
	- 虚继承
		- 虚基类依旧存在继承类中，只占用存储空间
		- 虚基类表存储的是虚基类相对直接继承类的偏移
	- 虚函数
		- 虚函数不占用存储空间
		- 虚函数表存储的是虚函数地址

# 21. 静态函数可以声明为虚函数吗？

**静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰**

static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义

虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。

# 22. 构造函数可以为虚函数吗？

构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。

为什么构造函数不可以为虚函数？

尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。

我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。 因此，构造函数没有必要被声明为虚函数。

# 23. 析构函数可以为虚函数吗？

析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。

析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

作者：力扣 (LeetCode) 链接：https://leetcode-cn.com/leetbook/read/cpp-interview-highlights/ef0i4d/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 24. 虚函数可以为私有函数吗？

- 基类指针指向继承类对象，则调用继承类对象的函数；
- int main()必须声明为Base类的友元，否则编译失败。 编译器报错： ptr无法访问私有函数。 当然，把基类声明为public， 继承类为private，该问题就不存在了。

# 25.虚函数可以被内联吗？

**通常类成员函数都会被编译器考虑是否进行内联。 但通过基类指针或者引用调用的虚函数必定不能被内联。 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。**

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

# 26 RTTI与dynamic_cast¶

RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用[基类](https://baike.baidu.com/item/基类/9589663)的[指针](https://baike.baidu.com/item/指针/2878304)或引用来检查这些指针或引用所指的对象的实际[派生类](https://baike.baidu.com/item/派生类)型。

在面向对象程序设计中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof，以及C#的as、is运算符类似，C++提供了dynamic_cast函数用于动态转型。相比C风格的强制类型转换和C++ reinterpret_cast，dynamic_cast提供了类型安全检查，是一种基于能力查询(Capability Query)的转换，所以在多态类型间进行转换更提倡采用dynamic_cast。

# 27. volatile使用

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

# 28. 友元

友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：

（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。

（2）友元类：类A中的成员函数访问类B中的私有或保护成员

优点：提高了程序的运行效率。

缺点：破坏了类的封装性和数据的透明性。

总结： - 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制

# 29. 进程间通信的几种方式

1. 1

	无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

2. 2

	高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。

3. 3

	有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

4. 4

	消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. 5

	信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

6. 6

	信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

7. 7

	共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

8. 8

	套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

# new和malloc的区别

[new和malloc的区别](https://www.notion.so/9f7b1770e6e3473b8de904134fcca893)

# DNS 的过程？

关于DNS的获取流程：

DNS是应用层协议，事实上他是为其他应用层协议工作的，包括不限于HTTP和SMTP以及FTP，用于将用户提供的主机名解析为ip地址。

具体过程如下：

①用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了

②浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如

```
<http://www.baidu.com/>
```

, 并将这个主机名传送给DNS应用的客户端③DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）

④该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址

⑤一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接

# DNS 查询的过程

1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。

2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。

3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。

5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。

6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

# get post

GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被Bookmark，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST么有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。GET参数通过URL传递，POST放在Request body中。

GET产生一个TCP数据包；POST产生两个TCP数据包。

# **请你来说一说用户态到内核态的转化原理**

1）用户态切换到内核态的3种方式

1、系统调用

这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。

2、异常

当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。

3、外围设备的中断

当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

2）切换操作

从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：

1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。

2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

# 状态码404

请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

# 为什么有了malloc/free还需要new/delete

1、malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符，它们都可用于申请动态内存和释放内存。

2、对于非内部数据类型的对象而言，比如C++类，光用maloc/free无法满足动态对象的要求。C++类对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。

3、 既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果不会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。

# 网络应用的Socket API编程的基本调用流程

一、服务端

1.首先我们知道在客户端和服务器之间我们必须先开启服务器进程，以此来等待客户端的连接，所以我们先来看一下服务器的初始化流程：

1.1服务器调用WSAStartup（)函数，来初始化套接字进程；

```
int WSAStartup(WORD wVersionrequest，LPWSADATA IpWSADATA)
#参数：第一个参数：为指明程序调用的winsocket版本，为十六进制，高字节表示副版本，低字节表示低版本
```

1.2紧接着调用socket()函数来创建一个全局的套接字对象，并返回对象句柄s;

```
s = socket(protofamily,type,family)
#创建套接字并返回句柄s
#参数，Protofamily：为协议族；Protofamily = PF_INET(TCP/IP)
# type:套接字类型；取值为SOCKET_STREAM、SOCKET_DRRAM、SOCKET_RAW
# family(协议号，默认为0)
```

1.3在创建 全局套接字s后，我们需要在服务器上绑定来自不同客户端的ip地址和端口号，（这里采用的bind（）为INADDR_ANY也就是地址通配符的动态绑定机制绑定不同的地址）

```
int bind(sd, localaddr,addrlen)
#绑定套接字的本地端口地址（ip地址+端口号）
#参数：sd为套接字描述符；localaddr(端点地址)
```

1.4在绑定之后，服务器就只要处于监听状态了，来监听来自客户端的请求等：

```
int listen(sd,squeuesize)
#参数sd为套接字描述符
#参数squeuesize设置信息队列大小
#返回值：0表示成功，SOCKET_ERROR表示失败
#listen函数仅仅面向连接的流套接字（tcp）;只有服务器才需要监听函数
```

1.5 accept函数，服务程序调用 ns = accept（）函数来从监听状态的流套接字中取出队列的第一个元素的客户端请求，并且

**创建一个新的套接字ns来与客户端套接字创建连接通道。**

1.6 通过accept函数的新建套接字ns，服务器与客户端套接字建立连接，通过套接字之间的通信，服务器端调用recv(）来接受客户端数据。此函数只适用TCP连接或者连接模式的UDP连接（也就是通过connect（）连接的udp连接）。

1.7 基于对recv()函数的收到请求，服务器端调用send(ns)返回给程序客户端信息。

1.8 如果基于套接字的客户端与服务器的通信完成之后，则调用closeSocket(ns)来关闭 当前的套接字。之后服务器端又恢复到listen的状态循环以上的accpet函数到closesocket()之间的步骤。如果套接字关闭不再使用，则关闭WSACleanup()来释放资源

二、客户端

在服务器端完成了accept（）步骤之后，我们的客户端就可以进行连接了。以下为类似的具体过程

2.1 同样是初始化WSAStartup()来初始化socket库

2.2 紧接着调用socket()函数来创建一个全局的套接字对象，并返回对象句柄s;

```
s = socket(protofamily,type,family)
```

2.3 在创建本地套接字之后我们就可以调用connect向服务器端发送连接请求。

2.4 在服务端收到连接请求之后，会发送连接确认到客户端，客户端收到连接确认之后，就调用套接字的send()函数发送流数据到服务器端。

2.5 在这之后客户端收到来自于服务器的信息之后，调用recv(s)函数来接受服务器发送的信息

2.6 在这个套接字完成通信之后，就可以关闭当前的套接字。最后基于对服务器的通信完成之后销毁套接字对象，释放资源（WSACleanUp）

注意：在上面的通信过程中，connect（）和accept()还有recv()函数都是会出现拥塞情况。可以考虑多并发的使用。

# 进程和线程，为什么要有线程

# 什么时候用自旋锁\互斥锁

## 自旋锁

如果让等待锁的线程处于忙等状态，一直消耗cpu资源，这种锁就叫做自旋锁。

自旋锁的代表：OSSpinLock

## 互斥锁

如果让等待锁的线程进入休眠状态，这种锁就叫做互斥锁。

互斥锁的代表：pthread_mutex

------

## 什么时候使用自旋锁比较划算？

1.线程等待锁的时间短

2.加锁的代码（临界区）频繁被访问，竞争不激烈

3.cpu资源不紧张

4.多核处理器

------

## 什么时候使用互斥锁比较划算？

1.线程等待锁的时间较长

2.单核处理器

3.临界区有IO操作

4.临界区操作复杂或者有大量循环

5.临界区竞争非常激烈

[互斥锁、自旋锁、读写锁、悲观锁、乐观锁_顽强拼搏的阿k的博客-CSDN博客](https://blog.csdn.net/weixin_38640052/article/details/108632310)

[字节跳动后端开发面经汇总（数据库与数据结构部分）_Kravchenko的博客-CSDN博客](https://blog.csdn.net/Kravchenko/article/details/105345649)

[字节跳动面经（操作系统与Python部分）_Kravchenko的博客-CSDN博客](https://blog.csdn.net/Kravchenko/article/details/105296834)

# strcpy 函数有什么缺陷，如何优化

1.strcpy

函数原型为char *strcpy(char *dest,const char *src);

函数说明：strcpy函数会将参数src字符串拷贝至参数dest所指的地址。

参数说明：dest，我们说的出参，最终得到的字符串。src，入参，因为其有const修饰。表示在此函数中不会也不能修改src的值。

返回值：返回dest字符串的起始地址。

附加说明：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误情况。

特别强调：此函数很好用，可是它也很危险。如果在用的时候加上相关的长度判断，则会大大降低出此错误的危险。此函数还有一个特点，就是它在把字符串b拷贝到字符串a的时候，会在拷贝的a字符串的末尾加上一个\0结束标志。这个不同于strncpy（）函数。

例如：

\#include<string.h>

main(){

char a[30]="string(1)";

char b[]="string(2)";

printf("before strcpy():%s\n",a);

if(strlen(b)<strlen(a)){

printf("after strcpy():%s\n",strcpy(a,b));

}

}

2.strncpy

函数原型为：char *strncpy(char *dest,const char *src ,size_t n);

函数说明：strncpy会将参数src字符串拷贝前n个字符至参数dest所指的地址。

返回值：返回参数dest的字符串起始地址。

特别强调：不要以为这个函数是个好东西，往往在定位问题时，它是罪魁祸首，到顶了，它是静态的容值函数，程序跑起来你就等着dbug吧。

strncpy的正确用法：

> strncpy(dest, src, sizeof(dest))；dest[sizeof(dest)-1] = ‘\0’;

1. size一定要用sizeof(dest)或sizeof(dest)-1，不可误用sizeof(src).
2. 手工填0. 务必要把dest的最后一个字节手工设置为0. 因为strncpy仅在src的长度小于dest时，对剩余的字节填0.
3. 性能问题。当dest长度远大于src时，由于strncpy会对多余的每个字节填0，会有很大的性能损失。
4. 返回值。strncpy返回dest，因而无法知道拷贝了多少个字节。

# 未初始化的全局变量放在哪里，编译后在二进制文件中有它的位置吗

BSS（二进制文件术语）　　是“Block Started by Symbol”的缩写，意为“以符号开始的块”。

BSS是Unix链接器产生的未初始化数据段。其他的段分别是包含程序代码的“text”段和包含已初始化数据的“data”段。BSS段的变量只有名称和大小却没有值。此名后来被许多文件格式使用，包括PE。“以符号开始的块”指的是编译器处理未初始化数据的地方。BSS节不包含任何数据，只是简单的维护开始和结束的地址，以便内存区能在运行时被有效地清零。BSS节在应用程序的二进制映象文件中并不存在。

在采用段式内存管理的架构中（比如intel的80x86系统），bss段（Block Started by Symbol segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。

比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。

text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。

# 什么是野指针，怎么检测

野指针：指向不确定地址的指针变量。（即没有初始化）使用野指针易因内存泄露出现段错误。而造成内存泄露的原因有两个：

1.访问了没有权限的内存（平时我们正确使用指针的时候，系统应经将相应的内存分配给用户，但是如果指向没有分配的内存，系统会判定我们没有权限）

2.访问了已经释放了的内存。

因为野指针主要是因为我们平时编程习惯造成的，因此我们只能避免野指针的出现，而不能杜绝。（请注意用词）我们在编程时，做到以下几点可以有效地避免野指针的出现。

第一，当一个指针没有指向时，我们一般默认指向NULL。（NULL代表内存的0地址，并且NULL是不允许做任何操作的）

第二，使用malloc分配内存。（在堆空间里分配内存）

\#difine  MAX_SIZE  1024；

char *ptr = （char *） maollc  （sizeof （char） * MAX_SIZE）；

请认真研究这样的表达式的优点，这个表达式在代码的维护性，扩展性都大大提高了。这方面是我们平时写代码时所应该提高的。

使用malloc也是有讲究的，我们应该依照下面的流程：

1.分配内存。（分配成功，返回内存的首地址；分配不成功，返回NULL）。

2.检查是否分配成功（若失败，则  exit（1） 退出程序）。

3.清空内存中的数据 （malloc分配的空间里可能存在垃圾值，因此我们需要清空，可以用到memset或bzero 函数）。

4.使用内存。

5.释放内存（free，这时ptr又变成野指针）。

6.写成NULL。

# 智能指针有哪些，实现原理，如何防止循环引用

如果你仔细思考 `std::shared_ptr` 就会发现依然存在着资源无法释放的问题。看下面这个例子：

```
struct A;
struct B;

struct A {
    std::shared_ptr<B> pointer;
    ~A() {
        std::cout << "A 被销毁" << std::endl;
    }
};
struct B {
    std::shared_ptr<A> pointer;
    ~B() {
        std::cout << "B 被销毁" << std::endl;
    }
};
int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->pointer = b;
    b->pointer = a;
}
```

运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 `a,b`，这使得 `a,b` 的引用计数均变为了 2，而离开作用域时，`a,b` 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 `a,b` 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露，如图 5.1：

![https://changkun.de/modern-cpp/assets/figures/pointers1.png](https://changkun.de/modern-cpp/assets/figures/pointers1.png)

图 5.1

解决这个问题的办法就是使用弱引用指针 `std::weak_ptr`，`std::weak_ptr`是一种弱引用（相比较而言 `std::shared_ptr` 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图 5.2 所示：

![https://changkun.de/modern-cpp/assets/figures/pointers2.png](https://changkun.de/modern-cpp/assets/figures/pointers2.png)

图 5.2

在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。

`std::weak_ptr` 没有 `*` 运算符和 `->` 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 `std::shared_ptr` 是否存在，其 `expired()` 方法能在资源未被释放时，会返回 `false`，否则返回 `true`。

# 能够使用 memcpy 判断两个结构体存的东西是一样的吗

# sizeof 和 strlen 的区别

Q：epoll和select/poll的区别 A：epoll是实现I/O多路复用的一种方法,有水平触发（level trigger，LT，默认)和边缘触发（edge trigger，ET）两种工作模式，区别在于两种模式的返回就绪状态的时间不同。水平触发和select/poll的方式一样

- 水平触发
	- 读：缓冲内容不为空返回读就绪
	- 写：缓冲区还不满返回写就绪
- 边缘触发
	- 读：
		- 缓冲区由不可读变为可读
		- 新数据到达，缓冲区中待读数据变多时
	- 写：
		- 当缓冲区由不可写变为可写
		- 当有旧数据被发送走，即缓冲区中的内容变少的时候

epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合就行了。

# **成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？**

使用成员初始化列表定义构造函数是显式地初始化类的成员，如果不用成员初始化列表，那么类对象对自己的类成员分别进行的是一次隐式的默认构造函数的调用（在进入函数体之前）初始化类的成员，和一次拷贝赋值运算符的调用（进入函数体之后），如果是类对象，这样做效率就得不到保障。

类类型的数据成员对象在进入构造函数体前己经构造完成，也就是说在成员初始化列表处进行对象的构造工作，调用构造函数，在进入函数体之后，进行的是对己构造好的类对象赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器默认的按成员赋值行为））。

# **20）必须在构造函数初始化列表里进行初始化的数据成员有哪些**？

(1) 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面(2) 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面(3) 没有默认构造函数的类类型，若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若成员类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

对象成员：A类的成员是B类的对象，在构造A类时需对B类的对象进行构造，当B类没有默认构造函数时需要在A类的构造函数初始化列表中对B类对象初始化

类的继承：派生类在构造函数中要对自身成员初始化，也要对继承过来的基类成员进行初始化，当基类没有默认构造函数的时候，通过在派生类的构造函数初始化列表中调用基类的构造函数实现。