---
title: 计算机组成原理
date: 2020-04-11 11:29:46
tags: [计组]
typora-root-url: ..
mathjax: true
---

大二学的计组

<!--more-->

# 难点





1. 主机框图, 以取数指令为例
2. **如何区分存放在存储器中的指令和数据**

![image-20200304091553718](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200304091553718-1586926358690.png)

3. 

![image-20200304094159786](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200304094159786-1586926358691.png)

























# 第一章 计算机系统概论

## 计算机系统简介

### 问题一: 现代计算机系统由哪两部分组成

分为硬件和软件。

### 计算机系统的软硬件概念

**硬件**： 计算机的实体，如主机、外设等。

**软件**： 由具有各类特殊功能的信息（程序）组成

软件分为**系统软件**和**应用软件**。

**系统软件**用来管理整个计算机系统，有**语言处理程序**、**操作系统**、**服务性程序**、**数据库管理系统**、**网络软件**

**应用软件**按任务需要编制成各种程序

### 计算机系统的层次结构

系统复杂性管理的方法——抽象。抽象是应对系统管理复杂性的重要方法。

![image-20200223130438445](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223130438445-1586926358691.png)

![image-20200223130622291](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223130622291-1586926358691.png)









**计算机组成与计算机体系结构从研究内容上来说有什么区别呢？**

计算机系统结构定义了计算机系统软硬件的交接点，定义了哪些功能由软件来实现，哪些功能由硬件来实现。提供了上层软件进行编写的时候和硬件交互的接口

**计算机体系结构：** //有无乘法指令

程序员所见到的计算机系统的属性、概念性的结构和功能特性

（指令系统、数据类型、寻址技术、I/O机理）

**计算机组成：**//如何实现乘法指令

实现计算机系统结构所体现的属性

（具体指令的实现）



## 计算机的基本组成

### **一: 冯诺依曼计算机的特点**

1. 计算机由五大部件组成：存储、运算、控制、输入、输出
2. 指令和数据以等同地位存于储存器，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序
6. 以计算器为中心

冯诺依曼机工作方式的基本特点是：**按地址访问并顺序执行指令**

![image-20200223133048264](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223133048264-1586926358691.png)

实线表示数据，虚线表示控制

**输入设备**：将信息转换成机器能识别的形式

**存储器**：存放数据和程序

**运算器**： 算术运算、逻辑运算

**控制器**：指挥程序运行

**输出设备**：将结果转换成人们熟悉的形式







#### 冯诺依曼计算机体系结构的问题:

1. 以运算器为中心，运算器负荷大，将成为计算机的瓶颈

2. 框图看起来比较乱，不具有层次化的特征



### 二： 计算机硬件框图

![image-20200303212433943](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200303212433943-1586926358691.png)

#### 1.以存储器为中心的计算机硬件框图

<img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200223141919273.png" alt="image-20200223141919273" style="zoom:67%;" />

#### 2.现代计算机硬件框图

![image-20200223141955198](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223141955198-1586926358691.png)



#### 3.第二种应对系统复杂性管理的方法-3‘Y

1. **层次化（Hierachy）：**将被设计的系统划分为多个模块或子模块
2. **模块化（Modularity）**： 有明确定义的功能和接口
3. **规则性（regularity）**： 模块更容易被重用

### 三： 计算机的工作步骤

#### 1.上机前的准备

建立数学模型

确定计算方法

编制结题程序

#### 2.存储器的基本组成

<img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200223150903242.png" alt="image-20200223150903242" style="zoom:80%;" />

**存储体**  -  **存储单元**  -  **存储元件**

大楼      -      房间     -      床位

**存储单元**： 存放一串二进制代码

每个存储单元包含若干个**存储元件**（**存储基元**、**存储元**）

**存储字**： 存储单元中的二进制代码

**存储字长**： 存储单元中二进制代码的位数 每个存储单元赋予一个地址号



注意:   存储字长和**机器字长**的区别



按地址寻访

**MAR**（memory adress register)：存储器地址寄存器，反映**存储单元的个数**，相当于是房间的个数。如MAR为10位，则有2的10次=1024个存储单元

**MDR**(Memory data register)： 存储器数据寄存器，反映**存储字长**，相当于一个房间有几个床位。

<img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200223151932546.png" alt="image-20200223151932546" style="zoom:80%;" />





#### 3.运算器的基本组成及操作过程

![image-20200223153045731](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223153045731-1586926358691.png)

现在给出的运算器结构是教材上的模型机给出的结构。

如果不是累加型的计算机，而是通用型的计算机，则结构和寄存器的数量会发生相应的变化



ACC(accumulator): 累加器

MQ(multiplier-Quotient Register): 乘商寄存器

X: 操作数寄存器



M表示存储器的任一地址号,[M]表示对应M地址号单元中的内容;

X表示X寄存器,[X]表示X寄存器中的内容;

ACC表示累加器,[ACC]表示累加器中的内容;

MQ表示乘商寄存器,[MQ]表示乘商寄存器中的内容;





**乘法操作过程:**

​	将[ACC]看做被乘数, 先取出存放在主存M号地址单元中的乘数[M]并送入乘商寄存器MQ, 再把被乘数送入X寄存器, 并将ACC清零, 然后[X]和[MQ]相乘, 结果的高位保存在ACC中, 低位保存在MQ中。



**除法操作过程：**

![image-20200223161103270](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223161103270-1586926358691.png)

#### 4.控制器的基本组成

**控制器的功能？**

​	解释指令

​	保证指令的按序执行



**取指过程**： 命令存储器读出一条指令

**分析过程**： 对这条指令进行分析，指出该指令要完成什么样的操作， 并按寻址特征指明操作数的地址

**执行过程**：根据操作数所在的地址以及指令的操作码完成某种操作



**控制器**由程序计数器（**P**rogram **C**ounter），指令寄存器（**I**nstruction **R**egister）以及控制单元（**CU**）组成。



**PC**用来**存放**当前欲执行指令的**地址**,具有自动加1的功能, 可自动形成下一条指令的地址



**IR**用来**存放**当前的**指令**, IR的内容来自主存的MDR

IR的操作码(OP(IR))送至CU, 记作**OP(IR)->CU**, 用来分析指令

IR的地址码(Ad(IR))作为操作数的地址送至存储器的MAR,记作**Ad(IR)->MAR**



**CU**用来分析当前指令须完成的操作, 并发出各种微操作命令序列, 用来控制所有被控对象。



#### 5.主机完成一条指令的过程 // 重点:主机框图

**问题:**  

​	**如何区分存放在存储器中的指令和数据**

![image-20200304090807064](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200304090807064-1586926358691.png)

















![image-20200223181929845](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223181929845-1586926358691.png)

要执行的指令的地址保存在PC当中，指令保存在存储体中。

1. PC要把指令的地址送给MAR
2. MAR把指令的地址送给存储体
3. 在控制器的控制下，存储体把指定存储单元中保存的那条取数指令取出来，送入到MDR中
4. 取出来的指令送入IR， IR的功能就是保存当前正在执行的这条指令。 到目前为止，取指的工作就完成了

5. 分析指令只要把IR中保存的操作码部分送给CU，经过译码之后CU送出相应的信号去控制相应的执行部件去操作。
6. 我们这条指令是取数指令，是把保存在内存单元M中的数据取到ACC这个寄存器当中，为了完成这个操作，在控制器的控制之下，我们要把指令当中的地址部分送给存储器，以便把数据从存储体当中取出来。所以要从IR开始， 因为IR保存了当前的指令，也保存了当前指令的操作数的地址。从IR的地址码部分把地址取出，送给MAR；
7. MAR再送给存储体；
8. 在控制器的控制下从存储体当中把我们取数指令要取的那个数取出来，送给MDR
9. MDR再把数送入ACC。



![image-20200223191145948](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200223191145948-1586926358691.png)

## 计算机硬件的主要指标

**机器字长,指令字长和存储字长可以相等也可以不相等**

指令字长:  一条指令的位数 与指令寄存器的位数有关

### 1.机器字长

CPU一次能够处理数据的位数, 与CPU中的**寄存器位数**有关

### 2.运算速度

**主频**

**核数,**每个核支持的线程数

**吉普森法**: 综合考虑每条指令的执行时间以及他们在全部操作中所占的百分比,即
$$
T_M = \sum_{i=1}^nf_it_i
$$
Tm是机器运算速度;  fi是第i种指令占全部操作的百分比数;ti为第i种指令的执行时间

**MIPS**:  Million Instruction Per Second

**CPI**:  Cycle Per Instruction 执行一条指令所需的时钟周期(机器主频的倒数)

**FLOPS**(Floating Point Operation Per Second): 浮点运算次数每秒

### 3.存储容量

存放二进制信息的总位数

![image-20200224095526770](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224095526770-1586926358691.png)

# 第二章 计算机的发展及应用

## 计算机的发展史

电子数字积分机和计算机 ENIAC, 用来解决当时国防部弹道研究实验室(BRL)开发新武器的射程和检测模拟运算表的问题.

所用的主要元件是**电子管**。



**用硬件技术的发展作为计算机分代的标志**

电子管->晶体管->中小规模集成电路->大规模集成电路->超大规模集成电路



**软件发展有一下几个特点**

1. 开发周期长
2. 制作成本昂贵
3. 检测软件产品质量的特殊性

**摩尔定律:**

微芯片上继承的晶体管数目每三年翻两番//每十八个月翻一番

## 计算机的应用

**CAD**

计算机辅助设计

**CAM**

计算机辅助制造

**CIMS**

计算机集成制造系统

## 计算机的展望

**芯片集成度提高受以下三方面的限制**

1. 芯片集成度受物理极限的制约

2. 按几何级数递增的制作成本

3. 芯片的功耗\散热\线延迟

**代替传统的硅芯片**

1. 光计算机

2. DNA生物计算机

3. 量子计算机















# 第三章 系统总线

## 总线的基本概念

### 1.为什么要使用总线

计算机使用总线结构便于**增减外设**,   同时减少了**信息传输线的条数**



### 2.什么是总线

总线是连接各个部件的信息传输线,  是**各个部件共享的传输介质**



### 3.总线上信息的传送

串行   ,传输距离比较长

并行  , 传输距离会比较短//因为距离长了,信号会变形





### 4.总线结构的计算机举例

1. **单总线结构框图**

![image-20200224104630364](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224104630364-1586926358691.png)

在同一时刻只有一个设备在使用总线, 会严重影响运行速度

2. **面向CPU的双总线结构框图**

![image-20200224104801689](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224104801689-1586926358691.png)

假如要在主存和IO设备进行传输, 只能以CPU作为连接. 会导致CPU执行任务的速度变慢.

3. **以存储器为中心的双总线结构框图**

   ![image-20200224104941112](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224104941112-1586926358691.png)

   

在单总线的基础上开辟一条CPU与主存之间的总线,称为存储总线. 这组总线速度高，只供主存与CPU之间传输信息。这样既提高了传输效率，又减轻了系统总线的负担，还保留了I/O设备与存储器交换信息时不经过CPU的特点。



## 总线的分类

### 片内总线

指芯片内部的总线

### 系统总线

1. 数据总线

   双向，其位数与机器字长、存储字长有关。数据总线的位数称为数据总线宽度，它是衡量系统性能的重要参数。如果数据总线的宽度为8位，指令字长为16位，那么CPU在取指阶段必须两次访问主存。

2. 地址总线

   用来指出数据总线上的**源数据或目的数据**在**主存单元或I/O设备**的地址。

   地址总线上的代码是用来指明**CPU欲访问的存储单元或I/O端口的地址**，由CPU输出，单向传输。总线的位数与存储单元的个数有关，如地址线为20根，则对应的存储单元个数为2的20次。

3. 控制总线

   用来发出各种控制信号的传输线。有输入也有输出。

   ![image-20200224111524625](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224111524625-1586926358691.png)

### 通信总线

用于**计算机系统之间**或**计算机系统与其他系统之间**的通信

传输方式有**串行通信总线**和**并行通信总线**













## 总线特性及性能指标

###  1.总线物理实现

![image-20200224112102910](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224112102910-1586926358691.png)











### 2. 总线特性

#### 机械特性

**尺寸**、形状、**管脚数**及**排列顺序**

#### 电气特性

**传输方向**和有效的**电平**范围

#### 功能特性

每根传输线的**功能**（地址、数据、控制）

#### 时间特性

信号的**时序**关系

### 3.总线的性能指标

#### 总线宽度

数据线的根数

#### 标准传输率

每秒传输的最大字节数（MBps）

#### 时钟同步/异步

同步、不同步（没有直接说异步，因为不同步也包括多种类型

#### 总线复用

**地址线**与**数据线**复用

总线复用可以减少总线中信号线的数量

#### 信号线数

地址线、数据线和控制线的**总和**

#### 总线控制方式

突发、自动、仲裁、逻辑、计数

#### 其他指标

负载能力













### 4.总线标准

![image-20200224113456044](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224113456044-1586926358691.png)















## 总线结构

#### 一、单总线结构

![image-20200224155625611](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224155625611-1586926358691.png)

导致的问题： 总线成为系统的瓶颈。

#### 二、多总线结构

##### 1.双总线结构

把存储总线和I/O总线进行分离，通道是用操作系统进行编写的

![image-20200224155956693](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224155956693-1586926358691.png)

##### 2.三总线结构

DMA(direct memory access)直接存储器访问 ， 可以有多个高速外设，全都连到DMA总线上

![image-20200224160058650](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224160058650-1586926358691.png)

##### 3.三总线结构的又一形式

CPU和主存之间信息交换的量非常大。

该结构解决了IO设备扩展的问题.

但是会影响外部设备的工作

![image-20200224160218485](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224160218485-1586926358691.png)

##### 4.四总线结构

包括局部总线\系统总线\高速总线\扩展总线

低速设备连接到扩展总线上

![image-20200224160240249](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224160240249-1586926358691.png)





#### 三、总线结构举例

##### 1.传统微型机总线结构

![image-20200224161407950](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224161407950-1586926358692.png)

##### 2.VL-BUS局部总线结构

![image-20200224161624028](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224161624028-1586926358692.png)

##### 3.PCI总线结构

![image-20200224162008588](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224162008588-1586926358692.png)

##### 4.多层PCI总线结构

![image-20200224162032199](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224162032199-1586926358692.png)

## 总线控制

#### 总线判优控制

##### 1.基本概念

主设备（模块）  对总线有  **控制权**

从设备（模块）  **响应 ** 从主设备发来的总线命令



总线判优控制可以分成两种方法： 

​	**集中式**和**分布式**



下面介绍**集中式**的

​		链式查询

只需要很少几根线就能按一定优先次序实现总线控制，并且很容易扩充设备，但是对电路故障很敏感，且优先级别低的设备可能很难获得请求。

![image-20200224163009300](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224163009300-1586926358692.png)

​		计数器定时查询

计数可以从0开始，此时一旦设备的优先次序被固定，设备的优先级就按0,1,2,3,4,5——n的顺序降序排列，且固定不变；计数也可以从上一次计数的终止点开始，即是一种循环方法，此时设备使用总线的优先级相等；计数器的初始值可以由程序设置，所以优先次序可以改变。这种方式对电路故障不如链式查询方式敏感，但是增加了控制线（设备地址）数，控制也较复杂

![image-20200224163819323](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224163819323-1586926358692.png)



​		独立请求方式

响应速度快，优先次序控制灵活，但是控制线数量多，总线控制更复杂。

链式查询中仅用两根线确定总线使用权属于哪个设备，**在计数器查询中大致用log2n根线，其中n是允许接纳的最大设备数，而独立请求方式需采用2n根线。**

![image-20200224164800755](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200224164800755-1586926358692.png)









#### 总线通信控制

##### 目的: 

解决通信双方 **协调配合** 问题



##### 总线传输周期：	

​		1. 申请分配阶段  **主模块申请**，总线仲裁决定

​		2. 寻址阶段          主模块向从模块 **给出地址** 和 **命令**

​		3. 传数阶段    	  主模块和从模块 **交换数据**

​		4. 结束阶段  		主模块 **撤销有关信息**





##### 总线通信的四种方式

同步通信  由 **统一时标**控制数据传送

异步通信  采用 **应答方式**， 没有公共时钟标准

半同步通信  **同步、异步结合**

分离式通信  充分**挖掘系统总线**每个瞬间的潜力



1. 同步式数据输入\输出

要求总线的长度比较短

![image-20200225100836218](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200225100836218-1586926358692.png)

![image-20200225100848619](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200225100848619-1586926358692.png)





2. 异步通信

异步通信是通过请求和回答这两个信号来完成的



![image-20200225101044980](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200225101044980-1586926358692.png)







3. 半同步通信(同步异步结合)

同步特点:  发送方用**时钟前沿**发信号

​					接收方用**时钟后沿**判断识别

异步特点: 允许不同速度的模块和谐工作

​					增加一条**"等待"**响应信号

![image-20200225101650550](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200225101650550-1586926358692.png)



**上述三种通信的共同点**

一个总线传输周期 (以输入数据为例)

主模块发指令、命令       **占用总线**

从模块准备数据               **不占用总线**

从模块向主模块发数据    **占用总线**





为了充分挖掘系统总线每个瞬间的潜力，就引出了**分离式通信**

4. 分离式通信

   一个总线传输周期分为两个子周期

   子周期1： 主模块申请占用总线，使用完之后即放弃总线的使用权

   子周期2： 从模块申请占用总线， 将各种信息送至总线上

**特点：**

1. 各模块有权申请占用总线

  2. 采用同步方式通信，不等对方回答
  3. 各模块准备数据时，不占用总线
  4. 总线被占用时，无空闲







# 第四章 存储器

## 概述

### 1. 存储器分类

按存储介质进行分类(其实是三种, 半导体, 磁表面 ,  光)

- 半导体存储器   TTL,  MOS                       **易失**
- 磁表面存储器   磁头, 磁载体                    **非易失**
- 磁芯存储器       硬磁材料, 环状元件        **非易失**
- 光盘存储器       激光,  磁光材料               **非易失**





按存取方式分类

- 存取时间与物理地址**无关(随机访问)**
  - 随机存储器  在程序执行过程中   **可 读 可 写**
  - 只读存储器  在程序执行过程中    **只读**
- 存取时间与物理地址**有关 ( 串行访问)**
  - 顺序存取存储器    磁带
  - 直接存取存储器    磁盘



按在计算机中的作用分类

- 主存储器
  - RAM     可读可写,随机访问存储器
    - 静态RAM
    - 动态RAM
  - ROM     只读存储器
    - MROM
    - PROM
    - EPROM
    - EEPROM
- Flash Memory
- 高速缓冲存储器(Cache)
- 辅助存储器   
  - 磁盘
  - 磁带
  - 光盘







### 2. 存储器的层次结构

**存储器三个主要特性的关系**

![image-20200229131143613](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200229131143613-1586926358692.png)

**缓存-主存层次和主存-辅存层次**

![image-20200229131333830](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200229131333830-1586926358692.png)





## 主存储器

### 1.概述

#### 主存的基本组成

![image-20200229164433419](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200229164433419-1586926358692.png)



#### 主存与CPU之间的关系

![image-20200229164757581](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200229164757581-1586926358692.png)

三种信号:  数据总线\控制总线\地址总线  的信号

#### 主存中存储单元地址的分配

![image-20200301180925572](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200301180925572-1586926358692.png)



#### 主存的技术指标

- **存储容量**

主存, 存放二进制代码的总位数

- **存取时间**

存储器的访问时间(读出时间、访问时间）

- **存取周期 >存取时间**

**连续两次独立**的存储器操作（读或写）所需的**最小时间间隔**

- **存储器的带宽** 

单位 : 位/秒

### 2.半导体存储芯片简介

#### 半导体存储芯片的基本结构

![image-20200301181332834](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200301181332834-1586926358692.png)

1. 存储矩阵: 由大量相同的位存储单元阵列构成
2. 译码驱动: 将来自地址总线的地址信号翻译成对应存储单元的选通信号,该信号在读写电路的配合下完成对被选中单元的读/写操作
3. 读写电路: 包括读出放大器和写入电路, 用来完成读/写操作
4. 读/写控制线: 决定芯片进行读/写操作
5. 片选线: 确定哪个存储芯片被选中, 可用于容量扩充
6. 地址线: 是单向输入的,其位数与读出或写入的数据位数有关
7. 数据线数和地址线数共同反映存储芯片的容量大小.  如地址线10根,  数据线8个,  则芯片容量=$2^{10}*8=8K位$



**片选的作用:**

- 让某一芯片或某些芯片同时工作  (对容量稍大的芯片不合适

![image-20200301182043965](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200301182043965-1586926358692.png)



#### **半导体存储芯片的译码驱动方式**

(1) 线选法

![image-20200301184140484](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200301184140484-1586926358692.png)







(2)重合法

![image-20200301184238538](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200301184238538-1586926358692.png)





### 3.随机存取存储器

![image-20200306102828954](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306102828954-1586926358692.png)

![image-20200306110534068](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306110534068-1586926358692.png)

#### 静态RAM(SRAM)

static Random access Memory 

(1)静态RAM基本电路

保存0和1的原理是  **双稳态触发器**

![image-20200301184711729](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200301184711729-1586926358692.png)

![image-20200302091538460](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200302091538460-1586926358692.png)

![image-20200302091552826](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200302091552826-1586926358693.png)



静态RAM举例:

Intel 2114

A9~A4  行地址

A3~A0  列地址

I/O 每次存储和读出都有4个信号

WE写使能

CS片选使能



![image-20200302092721781](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200302092721781-1586926358693.png)

**用重合法可以实现选一次四列**

![image-20200302092856986](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200302092856986-1586926358693.png)

行地址是6位的,  可以有64个地址

列地址是4位的, 可以有16个地址 

一个64x64的矩阵, 被竖着切分成了4组, 每组有16列, 64行不变.

行地址选中64行中的1行,  列地址选中每一组的第n列,  这样就可以一次性选中4列.



![image-20200302093937610](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200302093937610-1586926358693.png)





#### 动态RAM(DRAM)

dynamic Random access Memory 

##### DRAM的刷新

1. **多久需要刷新一次**?

刷新周期:一般为2ms

2. **每次刷新多少存储单元**

以行为单位, 每次刷新一行存储单元

3. **为什么要用行列地址**?

减少选通线的数量

![image-20200306103620672](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306103620672-1586926358693.png)

4. **如何刷新**? 

有硬件支持,读出一行的信息后重新写入, 占用一个读/写周期

5. **在什么时刻刷新**?

假设DRAM内部结构排列成128*128的形式, 读/写周期0.5us,   2ms共4000个周期

思路一:**每次读写完都刷新一行**

![image-20200306104354203](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306104354203-1586926358693.png)



思路二:**2ms内集中安排时间全部刷新**

![image-20200306104420607](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306104420607-1586926358693.png)



思路三:**2ms内每行刷新一次即可**

![image-20200306104442408](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306104442408-1586926358693.png)



保存0和1的原理是  **电容**

![image-20200302095632717](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200302095632717-1586926358693.png)

#### 动态RAM芯片举例





### 4.只读存储器

掉电后不丢失, 又能直接和CPU通信. 但是速度慢

作用: 保存一些固定的信息

主存是由RAM和ROM组成的  read only memory

![image-20200306105630922](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200306105630922-1586926358693.png)



**主要类型**

1. 掩膜式只读存储器(MROM)

存储内容由半导体制造厂按用户提出的要求在芯片生产过程中直接写入,无法修改

2. 一次可编程只读存储器(PROM)

存储内容由用户用专门的设备(编程器)一次性写入,之后无法修改

3. 可擦除可编程只读存储器(EPROM)

分为紫外线擦除(UVEPROM)和电擦除(EEPROM)

修改次数有限, 写入时间很长

4. 闪速存储器(Flash Memory)

如U盘, 写入速度较快

5. 固态硬盘(Solid State Drives)

控制单元+FLASH芯片

### 5.存储器与CPU的连接

#### 存储器容量的扩展

##### 位扩展

目的: 增加存储字长

把两个芯片当做一个芯片来操作  :就是把两个芯片的片选端用相同的信号.

![image-20200309122113519](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200309122113519-1586926358693.png)



##### 字扩展

目的: 增加存储字的数量

![image-20200309122355447](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200309122355447-1586926358693.png)



##### 同时扩展（字、位扩展）

![image-20200309122842387](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200309122842387-1586926358693.png)



#### 存储器与CPU的连接

##### 地址线的连接

一般来说，都是把地址的低位作为地址送入存储器地址线当中，高位作为芯片选择信号。

##### 数据线的连接

CPU数据线条数可能比存储器数据线条数要多，所以要进行位扩展，使存储器输入输出的数据可以满足CPU的需求

##### 读写命令线的连接

一般来说， CPU给出读写命令，我们可以把读写线连接到每一个芯片上的读写控制端上，ROM除外。

##### 片选线的连接

非常重要。这次访问的地址空间落在哪一个或者哪几个芯片上是由片选线来决定的。

##### 合理选择存储芯片

ROM和RAM合理选择。  

一般ROM保存系统程序、配置信息

RAM：用户或系统程序运行的区域

选择芯片的规格、数量：芯片数量尽量少， 片选逻辑尽可能简单

##### 时序、负载

CPU时序和存储器的时序相互配合

CPU能够带多少个存储芯片

##### 例题

![img](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/FlgxwbiJ_QvP4gD6bcQklSyDGwpE-1586926358732)

![image-20200309125046850](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200309125046850-1586926358701.png)

CPU需要8位， 所以他的数据线根数是8位。





（2）确定芯片的数量和类型

因为没有1k x 8的芯片， 所以用2片1k x 4的芯片作为RAM

ROM有2kx8的

（3）分配地址线

MREQ信号是什么？

他给出了地址和读写控制信号，但是这个地址不一定对应的是主存当中某一个存储单元的地址， 也可能是IO端口中某个端口的地址，所以在片选信号中一定不要忘了MREQ这个信号

（4)确定片选信号

![image-20200309130248755](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200309130248755-1586926358701.png)

 

### 6.存储器的校验

**为什么要对存储器的信息进行校验？**

在外界环境的干扰下,存放在存储器中的信息可能出错, 因此需要进行校验.

**为了能够校验出信息是否正确，如何进行编码？** 



**纠错或检错能力与什么因素有关？** 

任意两组合法代码之间二进制位的最少差异数.

**校验出信息出错后是如何进行纠错？** 



**除了我们教材上讲的校验码，你还知道哪些容错编**

**码？，原理是什么？** 



#### 编码的最小距离

任意两组合法代码之间 **二进制位数** 的 **最少差异**

**编码的纠错、检错能力与编码的最小距离有关**
$$
L-1=D+C(D\ge C)
$$
L——编码的最小距离

D——检测错误的位数

C——纠正错误的位数

#### 汉明码的组成

采用分组、奇偶校验



**汉明码的组成需要添加?位检测位**

$2^k\ge n+k+1$

添加多少位就是分成多少组. 

n个信息位, k组, 

接收方的检测结果要检测出n+k位有哪一位错了, 还有一种是全部正确的情况

**检测位的位置**

$2^i(i=0,1,2,3,..)$

**检测位的取值**

检测位的取值与该位所在的检测“小组” 中承担的奇偶校验任务有关

![image-20200311113435277](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200311113435277-1586926358701.png)

![image-20200311113420542](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200311113420542-1586926358701.png)



 **汉明码的纠错过程**

形成新的检测位$P_i$, 其位数与增添的检测位有关, 如增添3位(k=3), 新的检测位为$P_4P_2P_1$ . 以k=3为例, $P_i$的取值为  

$P_i$通俗的说就是第i位是1的话, 就分到这个组.

![image-20200311113813770](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200311113813770-1586926358701.png)



![image-20200311113825091](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200311113825091-1586926358701.png)

















### 7.提高访存速度的措施

#### 1.单体多字系统

可以增加存储器的带宽

![image-20200310092541003](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200310092541003-1586926358701.png)

 **CPU要向存储器当中的某个存储单元写一个长度为16的字, 要先写入到单字长寄存器当中,再写到4个字长的数据寄存器中, 再到存储器当中**

问题: 我们可能只需要写16位,但是实际上写了48位.这个修改可能是错误的修改。

如果我们要取的数据或者指令不是连续地存放在相邻的地址当中的，比如说我们一次取出4条指令，但是这4条指令当中第一条就是跳转指令，而且跳转的范围比较大，超出了这4个字的范围，**那么我们取出来的这4条指令只有第一条是有用的，其他三条都没用了。**



#### 2.多体并行系统

##### （1）高位交叉

顺序编址

这种方式虽然已经有了并行的基础，但是会造成某个存储体特别繁忙，其他的特别空闲。

这种实际上就是存储器容量的扩展， 但并不利于提高存储器的带宽。

![image-20200310093609431](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200310093609431-1586926358701.png)

个体并行工作

**![image-20200310093832515](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200310093832515-1586926358701.png)**

##### （2）低位交叉

提高存储器的**带宽**和**访问速度**

各个体轮流编址

横向地编码。后两位给出了存储体的地址， 前面的4位给出了存储体内部的地址。

**不改变存取周期的前提下，增加存储体的带宽。**

![image-20200310093954919](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200310093954919-1586926358701.png)

通用方式

![image-20200310094428688](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200310094428688-1586926358701.png)

这种方式相当于以流水的方式来访问不同的存储体.

![image-20200310094511235](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200310094511235-1586926358701.png)



**问题:**

设四体低位交叉存储器，存取周期为*T*，总线传输周期为*τ*，为实现流水线方式存取，应满足 *T* ＝ 4τ

<img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200310094719544.png" alt="image-20200310094719544" style="zoom:67%;" />

连续读取**4个字**所需的时间为**T+(4-1)τ**



##### (3)高性能存储芯片

(1) SDRAM (同步 DRAM)

在系统时钟的控制下进行读出和写入, **CPU 无须等待**

(2) RDRAM

由 Rambus 开发，主要解决 **存储器带宽** 问题

(3) 带 Cache 的 DRAM 

在 DRAM 的芯片内 **集成** 了一个由 **SRAM** 组成的**Cache** ，有利于 **猝发式读取**

## 高速缓冲存储器

避免CPU"空等"现象,解决CPU与主存之间的速度匹配问题。

<img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200312083652082.png" alt="image-20200312083652082" style="zoom:50%;" />

**程序访问的局部性原理：**

​		时间的局部性:  当前正在使用的指令和数据以后也会使用到

​		空间的局部性：当前正在使用的指令和数据，相邻的指令和数据也会被用到

那么以上两部分的指令和数据应从主存中移到Cache中。

### Cache的工作原理

为什么Cache的块内地址和缓存块号,在实际应用中意义不大

#### 主存与缓存的编址

主存与缓存按块存储，块的大小相同，块内地址相同。

#### 命中与未命中

缓存共有 *C* 块

主存共有 *M* 块 *M* >> *C*

**命中：**

​	主存块**调入** 缓存 ，主存块与缓存块 **建立** 了对应关系

​	用 **标记记录** 与某缓存块建立了对应关系的 **主存块号**

**未命中即与命中相反**

#### Cache的命中率

CPU 欲访问的信息在 Cache 中的 比率

如果CPU访问Cache $n_1$次, 访问主存$n_2$次,那么命中率即$\frac {n_1}{n_1+n_2}$



**命中率与Cache的容量与块长有关。**

块长不够的话，CPU执行完几条指令，块就用完了。

太长的话Cache又放不下，一个大的块放到Cache中，可能只有一部分块是有用的，影响命中率。



**块长与一个存储周期内从主存调出的信息长度有关**

一般每块可取4~8个字。



#### Cache-主存系统的效率

效率e与命中率有关
$$
e=\frac{访问Cache的时间}{平均访问时间} \times 100 \%
$$
设Cache命中率为h, 访问Cache的时间为$t_c$,访问主存的时间为$t_m$, 则
$$
e=\frac{t_c}{h\times+(1-h)\times t_m}\times 100\%
$$
上面的公式访问Cache和内存是同时进行的, 才能得到这样的公司.

**如果CPU对存储器的一次访问, 先访问Cache, 在Cache没有命中的情况下再访问内存, 那么这个公式就会发生变化。**



### Cache的基本结构

![image-20200312091132793](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200312091132793-1586926358701.png)

###  Cache 的 读写 操作

#### 读

![image-20200316084735739](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200316084735739-1586926358701.png)

#### 写

根据Cache和主存的一致性分为两种:

##### 写直达法(Write-through)

写操作时,数据既写入Cache又写入主存

**写操作时间就是访问主存的时间**, Cache块退出时, 不需要对主存执行写操作, 更新策略比较容易实现.





##### 写回法(Write-back)

写操作时只把数据写入Cache而不写入主存

当Cache数据被替换出去时才写回主存

**写操作时间就是访问Cache的时间**,Cache块退出时, 被替换的块需写回主存,增加了Cache的复杂性.

### Cache的改进

#### 增加Cache的级数

分成片载(片内)Cache和片外Cache



#### 统一缓存和分立缓存

指令Cache    数据Cache

把指令和数据分别放在不同的Cache当中

与指令执行的控制方式有关 :    比如流水线的机器,避免在流水的过程当中改造成资源冲突.



### Cache-主存的地址映射

#### 直接相联映射

![image-20200316093901667](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200316093901667-1586926358702.png)

#### 全相联映射

![image-20200316094245029](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200316094245029-1586926358702.png)

#### 组相联映射

![image-20200316095404857](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200316095404857-1586926358702.png)



#### 替换算法

1. 先进先出 （ FIFO ）算法

2. 近期最少使用（ LRU）算法

**直接  //不灵活**

某一 主存块 只能固定 映射到 某一 缓存块

**全相联 成本高**

某一 主存块 能 映射到 任一 缓存块

**组相联**

某一 主存块 只能 映射到 某一 缓存 组 中的 任一块



##  辅助存储器

### 概述

特点: **不直接与CPU交换信息**



磁表面存储器的技术指标:

1. 记录密度      道密度$D^t$    位密度$D^b$

2. 存储容量

   $ C=n\times k \times s$  

   多少个盘面, 多少个磁道, 每个磁道多少个信息

3. 平均寻址时间  寻道时间+等待时间

辅存的速度包括寻址时间和磁头读写时间.

4. 数据传输率  $D^r = D^b \times V$

**位密度乘旋转的的速度**

4. 误码率  出错信息位数与读出信息的总位数之比



# 第五章 输入输出系统

## 输入输出系统的发展

1. 早期

外部设备和主机的连接采用 **分散连接**

外部设备和主机之间的连接主要采用 **程序查询方式**

CPU和I/O设备 **串行**, I/O进行数据输入输出的时候, CPU必须运行相应的程序或者处在平等状态.



2. 接口模块和DMA阶段

IO设备通过接口连接在总线上

CPU和IO设备 并行工作(中断方式\DMA方式)



3. 具有通道结构的阶段

通道可以看做是简单的处理器、或者是小型的功能更强的DMA控制器，可以执行通道程序。 

可以控制连接在通道上的IO设备， 和主机之间进行传输



4. 具有IO处理机的阶段

## 输入输出系统的组成

### I/O软件

1. I/O指令 ：CPU指令的一部分

![image-20200319095703715](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200319095703715-1586926358702.png)

操作码字段作为I/O指令与其他指令(如访存指令、算逻指令、控制指令等）的判别代码；

命令码体现I/O设备的具体操作;

设备码是多台设备的选择码;



2. 通道指令: 

对具有通道的I/O系统专门设置的指令,是通道自身的指令

指出数组的首地址、传送字数、操作命令



通道程序是由通道控制字(或称通道指令)组成

### I/O硬件

包含输入输出设备、输入输出接口。

如果采用通道方式，那么设备连接的是设备控制器， 设备控制器连接的是子通道，子通道连接通道 

### I/O设备与主机的联系方式

1. I/O设备的编址方式

**统一编址：** 

把I/O设备的地址看成是内存地址的一部分。

比如内存地址一共是1M， 我们把1M地址中的低地址或者高地址的64k拿出来作为I/O设备或者端口的地址。

如果输入输出是0，或者访存是0，他的地址码部分的地址落入到了IO地址部分，那么这次的输入输出或者读写操作实际上是针对I/O进行的。

在这种情况下，CPU可以直接利用取数或者是存数指令对IO进行访问，对IO设备进行控制。

我们不需要单独的I/O指令。只要取数指令或者是读数指令，它地址码部分的地址落到了I/O地址部分，那么这条取数或者是读数指令就是对I/O设备进行操作的。因此这种方式CPU系统的指令集会相对的简单。如果内存系统它的编址空间比较大的话，我们就可以采用统一编制的方式。

**不统一编址：**

有专门的I/O设备,需要设I/O专用指令 

2. 设备选址

用设备选择电路识别是否被选中

只要把CPU给出的地址和设备中保存的自己的地址进行比较

3. 传送方式

串行

并行

4. 联络方式

（1）立即响应

对于一些工作速度缓慢的设备,当她们与CPU发生联系时, 通常都处于某种等待状态, 只要CPU的I/O指令一到, 就可以响应

（2）异步工作采用应答信号

分为串行和并行。CPU和IO之间一般都是并行传输，所以现在讲的异步工作应答信号一般都是IO接口和IO设备之间采用的。

并行: 

![image-20200320102202373](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200320102202373-1586926358702.png)

串行:

![image-20200320102904801](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200320102904801-1586926358702.png)

(3) 同步工作采用同步时标

要求I/O设备与CPU的工作速度完全同步

5. I/O设备与主机的连接方式

(1) 辐射式连接

每台设备都配有一套控制线路和一组信号线,   不便于增减设备

(2) 总线连接

便于增删设备





### I/O设备与主机信息传送的控制方式

1. 程序查询方式

   CPU和I/O串行工作

   在数据准备的过程中, CPU一直处于原地踏步状态,没有去执行其他指令, 这样CPU的效率非常低

   <img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200320103501060.png" alt="image-20200320103501060" style="zoom:80%;" />

2. 程序中断方式

是对第一种的改进



I/O的工作分为两个阶段,  自身准备阶段、 与主机交换信息阶段。

自身准备阶段： CPU不查询

与主机交换信息： CPU暂停现行程序



特点：没有踏步等待现象， 由外部设备主动发出中断请求， 请求CPU协助完成数据的输入和输出。

![image-20200320104459091](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200320104459091-1586926358702.png)

3. DMA方式

![image-20200320105311576](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200320105311576-1586926358702.png)







## 外部设备

### 概述

外部设备大致分为3类：

1. 人机交互设备
2. 计算机信息存储设备
3. 机-机通信设备

### 输入设备

1. 键盘
2. 鼠标
3. 触摸屏

### 输出设备

1. 显示器
2. 打印机



### 其他

1. A/D、D/A

2. 终端 

由键盘和显示器组成

完成显示控制与存储、键盘管理及通信控制

3. 汉字处理 

汉字输入、存储、输出





## I/O接口

### 概述

为什么设置接口？

1. 实现设备的选择
2. 实现数据缓冲达到速度匹配
3. 实现数据串-并格式转换
4. 实现电平转换
5. 传送控制命令
6. 反映设备的状态（“忙”“就绪”“中断请求”）

### 接口的功能和组成

#### **（1）总线连接方式的I/O接口电路**

**设备选择线**（单向线）

根数取决于I/O指令中设备码的位数 

如果把设备码看作是地址号, 

**数据线**（双向

通常是双向, 也可以是单向. 如果是单向数据线,则必须用两组.

根数一般等于存储字长或字符的位数

**命令线** (单向

其根数与命令信号的多少有关

**状态线**(一组单向线

<img src="C:\Users\fay\iCloudDrive\计算机组成原理\计算机组成原理.assets\image-20200320115609608.png" alt="image-20200320115609608" style="zoom:80%;" />

#### **(2)接口的功能和组成**

功能: 

- 选址功能
- 当设备选择线上的设备码与本设备码相符时, 应发出设备选中信号SEL, 这种功能通过设备选择电路来实现.
- 传送命令
- 命令寄存器用来存放I/O指令中的命令码,它受设备选中信号控制。只有被选中设备的SEL信号有效，命令寄存器才能接受命令线上的命令码

- 传送数据
  - 要求接口中具有数据通路,完成数据传送. 接口中通常设有数据缓冲寄存器(Data Buffer Register,DBR), 用来暂存I/O设备与主机准备交换的信息, 与I/O总线中的数据线是相连的
- 反映设备状态
  - 如完成触发器D和工作触发器B, 
  - D=0,B=0表示设备处于暂停状态
  - D=1,B=0表示设备已经准备就绪
  - D=0,B=1表示I/O设备正处于准备状态.





组成:

- 设备选择电路
- 命令寄存器、命令译码器
- 数据缓冲寄存器
- 设备状态标记



反映系统的状态使用状态标记触发器：

- 完成触发器D
- 工作触发器B
- 中断请求触发器 INTR
- 屏蔽触发器 MASK

如果MASK=1. 表示尽管设备已经完成了工作， 但是依然不能向CPU或主机发出中断请求, 因为当前主机处理的工作比输入输出操作的重要性大.

#### **(3) I/O的基本组成**

![image-20200320120106039](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200320120106039-1586926358702.png)

### 接口类型

**1.** **按数据** **传送方式** **分类**

串行  intel 8251

并行 intel 8255

**2.** **按功能** **选择的灵活性** **分类**

可编程接口 intel 8255\8251

不可编程接口 intel 8212

**3.** **按** **通用性** **分类**

通用接口 intel 8255\8251

专用接口 intel 8279\8275

**4.** **按数据传送的** **控制方式** **分类**

中断接口 intel 8259

DMA接口 intel 8257a

## 程序查询方式

### 程序查询方式的流程

#### 单个设备的查询流程:

1. 检查状态标记   //测试指令
2. 准备就绪?  //转移指令
3. 交换数据  //传送指令或输入输出指令或访存指令



#### 多个设备的查询流程:

![image-20200324175649334](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200324175649334-1586926358702.png)

#### 程序流程:

保存寄存器的内容

![image-20200324180055861](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200324180055861-1586926358702.png)



### 程序查询方式的接口电路

![image-20200324180245665](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200324180245665-1586926358702.png)

设备选择电路: 由他来确认一个设备是否就是参加这次传输的设备

## 程序中断方式

### 中断的概念

### I/O中断的产生

### 程序中断方式的接口电路

#### 配置中断请求触发器和屏蔽触发器

![image-20200327093532915](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200327093532915-1586926358702.png)



#### 排队器

![image-20200327093549508](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200327093549508-1586926358702.png)



#### 中断向量地址形成部件

![image-20200327093805028](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200327093805028-1586926358702.png)

#### 程序中断方式接口电路的基本组成

![image-20200327093930279](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200327093930279-1586926358702.png)

### I/O中断处理过程

CPU响应中断的时间一定是在每条指令执行阶段的结束时刻。

#### CPU响应中断的条件和时间

##### 条件: 

允许中断触发器 EINT = 1;

用 开中断 指令将EINT置 "1"

用 关中断 指令将EINT置"0"或 **硬件自动复位**

##### 时间

当I/O设备准备就绪的时间(即D=1)是随机的, 而CPU是在每条指令执行阶段的结束时刻前向接口发送中断查询信号,即将EINT置1;

![image-20200331161118482](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200331161118482-1586926358702.png)



### 中断服务程序流程













# 第六章 计算机的运算方法

整数原码的定义:

$[x]_原=0,x$     $2^n>x\ge 0$

$[x]_原=2^n-x$     $0\ge x>-2^n $

小数原码的定义:

$[x]_原=x$             $1>x\ge 0$

$[x]_原=1-x$          $0\ge x> -1$







整数补码的定义:

$[x]_补 = 0,x$     $2^n>x\ge 0$

$[x]_补=2^{n+1}+x$     $0> x>-2^n $

小数补码的定义:

$[x]_补=x$             $1>x\ge 0$

$[x]_补=2+x$          $0> x\ge -1$ (mod 2)



整数反码的定义:

$[x]_反 = 0,x$     $2^n>x\ge 0$

$[x]_反=(2^{n+1}-1)+x$     $0\ge x>-2^n $

小数反码的定义:

$[x]_反=x$             $1>x\ge 0$

$[x]_反=(2-2^{-n})+x$          $0\ge x> -1  (mod(2-2^{-n}))$ 





整数移码的定义:

$[x]_移 = 2^n+x$     $2^n>x\ge -2^n$









![image-20200403091252824](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200403091252824-1586926358702.png)







总结:

​	1. 原码\反码中的0有+0和-0两种表示形式

​	2. 补码\移码中的0只有一种表示形式

​	3. 小数的-1只有补码能够表示, 因为补码中的0只有一种表示形式, 所以他能比原码多表示一个-1。

​	4. 不论真值是正的还是负的，由$[y]_补 求 [-y]_补$都是采用"**连同符号位在内,每位取反,末位加1**"的规则

​	5. 若机器码采用原码, 小数定点机中数的表示范围是$-(1-2^{-n}) to (1-2^{-n})$, n是数值部分的位数

整数定点机中数的表示范围是$-(2^n-1) to (2^{n}-1)$

6. 计算机中规定浮点数的尾数用纯小数形式。 尾数最高位为1的浮点数称为**规格化数**， 浮点数表示称规格化形式后， 其精度最高。

  7. 浮点数是用补码还是原码表示的？ //都可

8. 计算机中浮点数 的阶码和尾数可以采用同一种机器数表示, 也可以用不同机器数表示

9. 一旦浮点数的基数确定之后就不再变了, 而且基数是隐含的, 故不同基数的浮点数表示形式完全相同. 但基数不同，对数的表示范围和经度都有影响。  基数r越大， 可表示的浮点数范围越大， 而且表示的数的个数越多，但浮点数的精度反而下降
10. 当浮点机和定点机中数的位数相同时， 浮点数的表示范围比定点数大得多
11. 当浮点数为规格化数时，其相对精度远比定点数高
12. 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化， 故浮点运算步骤比定点运算步骤多，运算速度慢，运算线路复杂。
13. 当一个浮点数尾数是0时，不论阶码为何值；或阶码小于等于它所能表示的最小数时，不管尾数是何值，机器都把该浮点数认为是0.
14. 如果浮点数的阶码用移码表示，尾数用补码表示，则当阶码为他所能表示的最小数$2^{-m}$且尾数为0时, 其阶码(移码)全为0 ,尾数(补码)也全为0,这样的机器零为000...0000



## 定点运算

### 移位运算

![image-20200406100450085](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200406100450085-1586926358702.png)

算术移位的硬件实现

![image-20200406100544359](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200406100544359-1586926358702.png)

## 加减法

不论操作数是正还是负,在做补码加减法时,只需将符号位和数值部分一起参加运算,并且将符号位产生的进位自然丢掉即可



### 溢出判断

: 用一位符号位判断溢出

实际参加操作的两个数(减法时即为被减数和"求补"以后的减数)符号相同,结果又与原操作数的符号不同,即为溢出



为了节省时间,通常用符号位产生的进位与最高有效位产生的进位异或操作后,按其结果进行判断. 

**如果异或结果为1,即为溢出; 如果结果为0, 则无溢出.**





### 补码定点加减法所需的硬件配置



![image-20200415103300801](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200415103300801-1586926358702.png)

A和X的位数都是n+1位





## 乘法

### 原码乘法

p256

符号位单独处理

### 补码乘法

booth算法可以用于整数补码和小数补码

符号位在运算的过程中得出

最后一步不进行移位

![image-20200419160659159](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200419160659159.png)

## 原码除法

符号位是单独处理的



对于整数除法, 要求 $0<|除数| \le |被除数|$

整数除法的被除数位数可以是除数的两倍, 且要求被除数的高n位要比除数(n位)小, 否则为溢出

如果被除数和除数的位数都是单字长,则要在被除数前面加上一个字的0, 从而扩展成双倍字长再进行运算.







## 浮点四则运算



### 浮点加减运算

1. 对阶
2. 尾数求和
3. 规格化
4. 舍入
5. 溢出判断

![image-20200419211651262](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200419211651262.png)



#### 对阶

使两操作数的小数点位置对齐。

小阶向大阶看齐。使阶小的位数向右移位。（可能会使精度降低）



#### 尾数求和

对阶后将两个尾数按定点加减运算规则进行运算



#### 规格化

当基值r=2时，位数S的规格化形式为 $1/2 \le |S| <1$

如果采用双符号位的补码, 即**符号位要与数值位的最高位不同**



但是有两个特例:

一、S=-1/2的时候， $[S]_补 = 11.10000$, 此时对于真值-1/2而言, 他满足规格化形式,对于补码而言,他不满足符号位与数值最高位的条件, 为了便于判断, **规定-1/2不是规格化的数(对于补码而言**





二、S=-1， 则$[S]_补 = 11.00000$, 因小数补码允许表示-1, **故-1为规格化的数**





#### 舍入

0舍1入法



恒置一法



### 浮点乘除运算

两个浮点数相乘,  乘积的阶码应该是相乘两个数的阶码之和, 乘积的尾数应为相乘两个数的尾数之积



两个浮点数相除, 商的阶码是被除数的阶码减去除数的阶码, 尾数为被除数的尾数除以除数所得的尾数所得的商





**考试好像不用考**





## 算术逻辑单元

### 快速进位链

#### 并行加法器

n+1个全加器级联就组成了一个n+1位的并行加法器



一级一级传递进位的过程为大大影响运算速度



#### 串行进位链

指并行加法器中的进位信号采用串行传递

$d_i = A_iB_i$

$t_i = A_i+B_i$

设与非门的延迟时间为$t_y$, 那么当$d_i,t_i$形成之后, n位全加器的最长进位时间为$2nt_y$

#### 并行进位链

理想的并行进位链是n位全加器的n位进位同时产生

##### 单重分组跳跃进位

将n位全加器分成若干小组, 小组内的进位同时产生, 小组与小组之间采用串行进位

(组内并行,组间串行)



16位的延迟 2.5*4 = 10us

![image-20200420092541069](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420092541069.png)

![image-20200420092546432](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420092546432.png)

##### 双重分组跳跃进位

2.5*3 = 7.5us

![image-20200420092551652](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420092551652.png)







# 第七章 指令系统

## 指令的一般格式



### 操作码

指明该指令所要完成的操作. 其位数反映了机器的操作种类(机器允许的指令条数)



通常采用扩展操作码技术, 使操作码的长度随地址数的减少而增加.

![image-20200420092952486](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420092952486.png)









### 地址码

地址码用来指出该指令的源操作数的地址、结果的地址以及下一条指令的地址。



#### 四地址指令

如果地址字段均指示主存的地址， 则完成一条四地址指令共需访问4次存储器（取指一次， 取两个操作数两个， 存放结果一次）

![image-20200420095046918](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420095046918.png)

#### 三地址指令

如果指令字长不变， 其减少了地址码的个数， 则增加了直接寻址范围。

![image-20200420095951409](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420095951409.png)

#### 二地址指令

$(A_1)OP(A_2) \rarr A_1$

$A_1$字段既表示源操作数的地址， 又代表存放本次运算结果的位置。

![image-20200420100647831](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420100647831.png)

#### 一地址指令

完成一条一指令只需要两次访存

![image-20200420101010851](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420101010851.png)





#### 零地址指令

![image-20200420101033937](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420101033937.png)





### 指令字长

指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数

早期的计算机指令字长（与IR有关）、机器字长（与CPU寄存器长度有关）、存储字长（与MDR有关）均相等



后来指令字长是可变的, **按字节的倍数变化.**





## 操作数类型和操作类型

### 操作数类型

#### 地址

被认为是无符号的整数

#### 数字

定点数\浮点数\十进制数

#### 字符



#### 逻辑数据

在逻辑运算时n个0和1的组合不被看做是算术数字, 而是逻辑数

### 数据在存储器中的存储方式

计算机中的数据一般存放在存储器中或寄存器中, 而寄存器的位数便可反映机器字长.



在数据不对准边界的计算机中, 数据(例如一个字)可能在两个存储单元中, 此时需要访问两次存储器, 并对高低字节的位置进行调整只有才能取得一个字.





### 操作类型

#### 数据传送

包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送

#### 算术逻辑操作

算术运算 ： 加减乘除，增1， 减1， 求补

逻辑运算： 与或非、异或

#### 移位

算术移位、逻辑移位、循环移位

#### 转移

##### 无条件转移

不受任何条件约束

##### 条件转移

根据当前指令的执行结果来决定是否需要转移



SKP指令, 暗示其下一条指令将被跳过, 从而隐含转移地址是SKP后的第二条指令.



##### 调用与返回

包括 过程调用、系统调用、子程序调用。 可以实现从一个程序转移到另一个程序的操作



调用指令 CALL 一般与返回指令 RETURN 配合使用

由于在许多处可以调用子程序， 因此CPU必须记住返回地址， 使子程序能够准确返回。 返回地址可存放在：

1. 寄存器内. 机器内有专用寄存器,用于存放返回地址
2. 子程序的入口地址内
3. 栈顶内. 

##### 陷阱(Trap)与陷阱指令

是一种意外事故的中断,,

一般不提供给用户直接使用, 而作为隐指令在出现意外故障时, 由CPU自动产生并执行.



#### 输入输出



#### 其他

## 寻址方式

### 指令寻址

#### 顺序寻址

程序计数器PC加1, 自动形成下一条指令的地址

#### 跳跃寻址

用转移类指令实现



#### 数据寻址

指令的地址码字段通常都不代表操作数的真实地址, 把它称为**形式地址**, 记作$A  (address)$ . 

操作数的**真实地址**称为**有效地址**, 记作$EA$, 他是由寻址方式和形式地址共同决定的.

![image-20200420163231611](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420163231611.png)







假设指令字长, 存储字长, 机器字长均相同



##### 立即寻址

"#"是立即寻址特征标记

取出指令就能得到操作数, 速度快.  但是寻址范围小

![image-20200420163603753](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420163603753.png)

##### 直接寻址

形式地址$A$是操作数的真实地址$EA$

**在指令执行阶段**只访存一次, 也就是说, 整条指令还是要访存两次

![image-20200420163832648](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420163832648.png)

##### 隐含寻址

操作数的地址隐含在操作码或者某个寄存器中

有利于缩短指令字长

![image-20200420164015235](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200420164015235.png)

##### 间接寻址

有效地址是由形式地址间接提供的

这种寻址方式与直接寻址相比, 它**扩大了操作数的寻址范围.** 

因为A的位数通常小于指令字长, 而存储字长可与指令字长相等. 



若指令字长和存储字长均为16位, A位8位, 则直接寻址范围为$2^8$次, 一次**间接寻址的范围是$2^{16}$次.**

在多次间接寻址时, 用存储字的首位来标志间接寻址是否结束. 第一位是1的时候说明还需要继续访存寻址. 因此**它的寻址范围是$2^{15}$次**





它还便于编制程序。 **用间接寻址可以很方便地完成子程序的返回**

只要在**调用前先将返回地址存入子程序最末条指令的形式地址A的存储单元内**， 便可准确返回源程序断点。



##### 寄存器寻址

地址码字段直接指出了寄存器的编号, 即EA=R

其操作数在$R_i$所指的寄存器内。 由于操作数不在主存中 ，故寄存器寻址在指令执行阶段无须访存， 减少了执行时间。

由于地址字段只需指明寄存器编号， 故指令字较短， 节省了存储空间



##### 寄存器间接寻址

$R_i$中的内容不是操作数 , 而是操作数所在主存单元的地址号, 即有效地址$EA=(R_i)$, 与寄存器寻址相比, **指令的执行阶段**还需要访问主存

有效地址存放在寄存器中, 因此叫做寄存器间接寻址, 其比间接寻址少访存一次

##### 基址寻址

需设有基址寄存器BR, 其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容相加



可以扩大操作数的寻址范围

在多道程序中极为有用

##### 变址寻址

与基址寻址极为相似

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和

**与基址寻址的区别:** 

基址寻址主要为程序或数据分配存储空间, 故基址寄存器的内容通常由操作系统或管理程序确定, 在程序的执行过程中是不可变的, 而指令字中的A是可变的



而变址寻址中, 变址寄存器的内容是由用户设定的, 在程序执行过程中可变, 而指令字中的A是不可变的。

主要用于处理数组问题， 设定A为数组的首地址， 不断改变IX的内容， 就可以形成数组中任意数据的地址。



还可与基址寻址合用， 称为基址变址寻址， $EA= A+（IX）+（BR）$



或和间接寻址合用, 形成**先变址后间址**或**先间址后变址**的寻址方式





##### 相对寻址

"*"为相对寻址特征

将程序计数器PC的内容(即当前指令的地址)与指令字中的形式地址A相加而成

$EA= (PC)+A$

位移量A可正可负, 通常用补码表示.

若位移量为8位, 则指令的寻址范围为$(PC)+127 ~\sim(PC)-128$



也可配合间接寻址使用



## 指令格式举例









# 第八章 CPU的结构和功能

## cpu 的功能

### 取指

控制器必须具备能自动从存储器中取出指令的功能

### 分析

分析此指令要完成什么操作, 即控制器需发出什么操作命令

分析参与由这次操作的操作数地址, 即操作数的有效地址

### 执行

控制程序的输入和运算结果的输出、对总线的管理、处理中断的能力



CPU必须具有控制程序的顺序执行（指令控制）、产生完成每条指令所需的控制命令（称操作控制）、对各种操作加以时间上的控制（时间控制）、对数据进行算数运算和逻辑运算（数据加工）以及处理中断等功能





## CPU结构框图



![image-20200422094719136](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422094719136.png)

## CPU的寄存器

### 用户可见的寄存器

通用寄存器

数据寄存器

地址寄存器

条件码寄存器



### 控制和状态寄存器

MAR

MDR

PC

IR

通过上面的4个寄存器, CPU和主存可交换信息



程序状态字PSW寄存器, 存放条件吗和其他状态信息



还有其他的寄存器



## 指令周期

CPU每取出并执行一条指令所需的全部时间称为指令周期, 也即CPU完成一条指令的时间.



取指周期 $FE, fetch$: 取址阶段完成取指令和分析指令的操作

执行周期$EX, execute$: 执行阶段完成执行指令的操作.

中断周期$INT, interrupt$: 保存程序断点

间址周期$IND, indirect$: 取有效地址

### 指令周期的数据流

#### 取指周期的数据流

![image-20200422101001000](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422101001000.png)

#### 间址周期的数据流

![image-20200422101029701](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422101029701.png)

![image-20200422101035297](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422101035297.png)

#### 执行周期的数据流

不同指令在执行周期的操作不同, 所以无统一的数据流图



#### 中断周期的数据流

![image-20200422101053338](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422101053338.png)

### 指令流水

为了提高处理机速度可以:

1. 提高期间的性能
2. 改进系统的结构,开发系统的并行性





#### 指令流水原理

指令的执行时间一般大于取指时间

当遇到条件转移指令时, 下一条指令是不可知的, 因为必须等到执行阶段结束后, 才能获知条件是否成立, 从而决定下条指令的地址, 造成时间损失.

为了减少时间损失, 通常采用猜测法 , 即当条件转移指令从去取指阶段进入执行阶段时, 指令部件仍按顺序预取下一条指令. 如果条件不成立, 则没有时间损失. 如果条件成立, 转移发生, 则所取的指令必须丢掉



**可以将指令处理过程分解为更细的几个阶段:**

取指FI,fetch instruction:

指令译码DI, decode instruction:确定操作性质和操作数地址的形成方式

计算操作数地址CO,caculate Operand: 计算操作数的有效地址, 各种寻址方式的计算方式

取操作数FO, fetch operand: 从存储器取操作数, 如果操作数在寄存器内就不用执行该阶段

执行指令EI, execute instruction: 执行指令所需的操作,并将结果存于寄存器中

写操作数WO,write operand: 把结果存取存储器









#### 影响流水线性能的因素

![image-20200422103350113](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422103350113.png)

##### 结构相关:

当指令正在重叠执行过程中, 不同指令争用同一功能部件产生资源冲突时产生的

**解决方法1:**

让流水线在完成前一条指令对数据的存储器访问时, 暂停(一个时钟周期)取后一条指令的操作.

**解决方法2:**

设置两个独立的存储器分别存放操作数和指令, 以免取指令和取操作数同时进行时互相冲突, 使**取某条指令**和**取另一条指令的操作数实现时间上的重叠**

**解决方法3:**

指令预取技术, 基于访存周期很短的情况.



##### 数据相关

流水线中各条指令因重叠叠操作, 可能改变对操作数的读写访问顺序, 从而导致数据相关冲突

解决方法:

将相关指令延迟到所需操作数被写回到寄存器后再执行的方式. 但是要停顿较多的时钟周期

方法2: 

旁路技术活相关专用通路技术



**数据相关冲突可分为:**

RAW, WAR, WAW

![image-20200422104459775](/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20200422104459775.png)

##### 控制相关:

主要由转移指令引起, 使流水线的连续流动受到破坏



解决方法: 

尽早判别转移是否发生, 尽早生成转移目标地址

预取转移成功或不成功两个控制流方向上的目标指令

加快和提前生成条件码

提高转移方向的猜准率



### 流水线性能

#### 吞吐率

#### 加速比

#### 效率



### 流水线中的多发技术

##### 超标量技术

##### 超流水线技术

##### 超长指令字技术





## 中断系统

要解决的问题:

1. 各中断源如何向CPU提出中断请求
2. 当多个中断源提出中断请求时, 中断系统如何确定优先响应哪个中断源的请求
3. CPU在什么条件、什么时候、什么方式来响应中断
4. CPU响应中断后怎么保护现场
5. CPU响应中断后， 如何停止原程序的执行而转入中断服务程序的入口地址
6. 中断处理结束后， CPU如何恢复现场， 如何返回到原程序的间断处
7. 在中断过程中又出现了新的中断请求，CPU该如何处理



#### 中断请求标记和中断判优逻辑

##### 中断请求标记

INTR, 为1时, 表示中断源有请求



##### 中断判优逻辑

###### 硬件排队

链式排队器 和 设在CPU内的排队器

###### 软件排队

编写查询程序实现



#### 中断服务程序入口地址的寻找

##### 硬件向量法

由硬件产生向量地址, 再由向量地址找到中断服务程序的入口地址.

##### **软件查询法**

用软件查找中断你服务程序入口地址





#### 中断响应

条件: EINT = 1;

可被开中断指令置1, 关中断指令置0;

CPU总是在指令执行周期结束之后, 响应任何中断源的请求.

因为CPU在执行周期的结束时刻统一向所有中断源发送中断查询信号,只有此时 ,CPU才能知道哪个中断源有请求.







##### 中断隐指令

**是CPU在中断周期内由硬件自动完成的一条指令**

1. 保护程序断点:

保护程序断点就是要将当前程序计数器PC的内容保存到存储器中,  它可以保存到存储器的特定单元内, 也可以存入对战



2. 寻找中断服务程序的入口

硬件向量法: 将向量地址送至PC, 使CPU执行下一条无条件转移指令, 转至中断服务程序的入口地址

软件查询法: 将软件查询入口地址的程序首地址送至PC,使CPU执行中断识别程序



3. 关中断

在中断周期内必须自动关中断, 禁止CPU再次响应新的中断请求

