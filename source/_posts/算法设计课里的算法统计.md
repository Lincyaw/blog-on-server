---
title: 算法设计课里的算法统计
date: 2020-05-18 17:25:20
tags: [算法导论]
typora-root-url: ..
mathjax: true
---

2020年哈工大算法设计与分析

<!--more-->

# Max-min(A)

**寻找数组中的最大值和最小值**

## 方法一 暴力的优化解

1. 先将数组的前半部分和后半部分进行比较, 保证最小数在数组的前半部分,最大数在数组的后半部分
2. 再遍历一半的数组, 在前半部分找最小值, 后半部分找最大值.

### 复杂度分析:

第一个循环$\frac {n}{2}$, 第二个循环$2*\frac {n}{2}$, 2为本次循环的操作次数, 因为i=1的情况已经是默认情况, 所以减2

### 伪代码

input: 数组A[1,...,n]

output: 数组A[1,...,n]中的max和min

```c++
For i<- 1 to n/2 Do
    if A[i]>A[n-i+1]
        then swap(A[i],A[n-i+1]);
max <- A[n];
min <- A[1];
For i<- 2 to n/2 Do 
    if A[i]<min 
        then min<A[i];
    if A[n-i+1]>max 
        then max<-A[n-i+1];
```

## 方法二 分治思想

该问题有子结构, 整个数组的最大值等于**左半数组的最大值**和**右半数组的最大值**的最大值

整个数组的最小值等于**左半数组的最小值**和**右半数组的最小值**的最小值

```c++
Maxmin(low,high):
if high-low==1 //给出递归终止条件
    if A[low]<A[high]
     	then return(A[low],A[high]);
    else
        return (A[high],A[low]);
else //递归内容
    mid=(low+high)/2
    (x1,y1)=Maxmin(low,mid)
    (x2,y2)=Maxmin(mid+1,high)
    x=min{x1,x2}
	y=max{y1.y2}
	return (x,y);
```

### 复杂度分析:

迭代递归方程

$$T(1)=0$$

$$T(2)=1$$

$$T(n)=2T(n/2)+2=3n/2-1$$

与方法一相比其实没啥区别



# 分治应用-大数乘法

问题输入: 两个n位的整数X和Y

问题输出: 两个数的乘积



## 思想

X和Y可分为两部分

![image-20200518181937288](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200518181937288.png)

但是分析乘法的复杂性:

$T(1)=\Theta(1), n=1$

$$T(n)=4\Theta(n/2)+\Theta(n), n>1$$      一个乘法可以分解成4个乘法的子问题, 每个子问题的代价为$\Theta(n/2)$, 再加上分解成这4个子问题需要3次加法$\Theta(n)$,  两次移位$\Theta(n)+\Theta(n/2)$, 

经过计算可得$T(n)=\Theta(n^2)$, 相对于普通的乘法没有提升



**但是再变换一下子问题的形式**:

$XY=ac2^n+((a+b)(c+d)-ac-bd)2^{n/2}+bd$

观察这个式子, 乘法子问题变成了3个, 虽然加法次数增多了,但是没有改变量级

![image-20200518185532656](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200518185532656.png)

算法复杂度从$\Theta(n^2)$到了$\Theta(n^{1.59})$













# 分治应用-棋盘覆盖问题

On a $2^k× 2^k$chessboard，only one square is different, called **specific**.
In the chessboard cover problem, we use the following four kinds of L-shape cards to cover the whole chessboard squares except the specific, and request that there is no overlapping.

![image-20200518185904576](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200518185904576.png)

$2^k× 2^k$的棋盘一定可以分成4个一样的小正方形棋盘。其中一个棋盘有特殊点，其他三个没有。

那么可以用一个L型的卡片覆盖其他三个， 使每个小棋盘都有一个特殊点。 从而分解成4个子问题

![image-20200518190641772](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200518190641772.png)

## 方法可行性：

子问题结束时，即为棋盘大小为$2\times 2$时, 一定可以由一个特殊点加一个L型卡片组成, 所以方案可行。

## 复杂度分析：

$T(n)=4T(n-1)\Rightarrow T(n)=O(4^k)$

 











# 从分治思想到归并排序

![image-20200518205154407](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200518205154407.png)

## 复杂度分析

$T(n)=2T(n/2)+O(n)$
$T(n)=O(nlogn)$

## 伪代码

```c++
k为待排序数组的划分点,待排序数组为A[i:j]
MergeSort(A,i,j):
    k=(i+j)/2;
    MergeSort(A,i,k);//先divide,分到最后只有单个的情况
    MergeSort(A,k+1,j);
    //上面的结束之后,在i~k和k+1~j这两个区间内,数组分别是有序的, 下面要做的就是把这两个数组合并
    low=i; high=k+1; t=i;
    while low<=k && high<j do
        if A[low]<A[high] 
            B[t]=A[low]
            low++
            t++;
        else
            B[t]=A[high]
            high++;
            t++;
    if low<k
        for v=low to k do
            B[t]=A[v]
            t++;
    if high<j
        for v=high to j do
            B[t]=A[v]
            t++;
    //上面的结束之后,数组的i~j就是有序的了
    for v=i to j do
        A[v]=B[v];
             
```









# 分治思想-从n个不同的数中选择第i大的元素

$Input:   n个(不同)数构成的集合X,整数i,其中1\le i \le n$
$Output: x\in X使得X中恰有i-1个元素小于x$

```c++
Select(A,i)
    for j = 1 to n/5  //把所有数分成n/5组
        InsertSort(A[(j-1)*5+1 : (j-1)*5+5])//对每组进行排序
        swap(A[j],A[(j-1)*5+3]);//将每组的中位数放到最前面的
	x=Select(A[1:n/5],n/10);//继续划分, 找到中点的中点
	k=partition(A[1:n],x);//以x为划分点,比x小的放到x的左边,比x大的放到右边
//返回值k是x所在位置的下标
	if k==i
        return x;
	else if k>i
        return Select(A[1:k-1],i);
	else
       	return Select(A[k+1:n],i-k);
```





**partition() 划分函数**

算法思想：

1. 取一元素为轴点(pivot)，不妨取首元素为轴点，并将轴点的值备份；
2. 从向量的起始(low)和末尾(high)同时进行扫描；
3. 若nums[high] < pivot, 将其换到nums[low];若nums[low] > pivot,将其换到nums[high];
4. 当low与high位置重合后，将备份的pivot值填回nums[low].

```c++
int partition(vector<int>& nums, int low, int high) {
    // 任取一元素与首元素交换，以交换后的首元素作为基准
    int r = low + rand() % (high - low + 1);
    int tmp = nums[low];
    nums[low] = nums[r];
    nums[r] = tmp;
    int pivot = nums[low];
    // 由向量两端向中部扫描
    while (low < high) {
        while (low < high && pivot <= nums[high])//从右向左找小于pivot的数
            high--;
        nums[low] = nums[high];//pivot是初始nums[low]的值,因此可以大胆赋值
        //赋值之后,nums[high]就相当于是空出来了,就可以让比pivot大的数移到右边
        while (low < high && pivot >= nums[low])
            low++;
        nums[high] = nums[low];
    }
    nums[low] = pivot;//最后还剩一个坑位,留给pivot的
    return low;//返回pivot的坑位
}
```

上述partition算法返回轴点nums向量中的位置.

显然，该划分算法的时间复杂度是$O(n)$，空间复杂度为$O(1)$.





**以上伪代码在leetcode上的实现, 速度还没有随机选取中枢点的快:**

```C++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int size=nums.size();
        return select(nums,0,size-1,size-k+1);
    }
    int select(vector<int>& nums,int left,int right,int k)
    {
        if(left==right)
            return nums[left];
        int pivot_index=partition(nums,left,right);
        if(k==pivot_index+1)
            return nums[pivot_index];
        else if(pivot_index+1<k)
            return select(nums,pivot_index+1,right,k);
        else
            return select(nums,left,pivot_index-1,k);
    }
    int partition(vector<int>& nums, int low, int high) 
    {
        int pivot_index = rand()%(high-low+1)+low;
        swap(nums[low],nums[pivot_index]);
        int pivot=nums[low];
        // 由向量两端向中部扫描
        while (low < high) 
        {
            while (low < high && pivot <= nums[high])//从右向左找小于pivot的数
                high--;
            nums[low] = nums[high];//pivot是初始nums[low]的值,因此可以大胆赋值
            //赋值之后,nums[high]就相当于是空出来了,就可以让比pivot大的数移到右边
            while (low < high && pivot >= nums[low])
                low++;
            nums[high] = nums[low];
        }
        nums[low] = pivot;//最后还剩一个坑位,留给pivot的
        return low;//返回pivot的坑位
    }
};


作者：pedestrian-r
链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/day23-di-ida-de-shu-by-pedestrian-r/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





# 分治应用-随机快速排序

即再用一个函数递归调用上面那个`partition`即可

**C++实现代码:**

```c++
#include<iostream>
#include<vector>
using namespace std;
int partition(vector<int>& nums, int low, int high)
{
    // 任取一元素与首元素交换，以交换后的首元素作为基准
    int r = low + rand() % (high - low + 1);
    int tmp = nums[low];
    nums[low] = nums[r];
    nums[r] = tmp;
    int pivot = nums[low];
    // 由向量两端向中部扫描
    while (low < high) {
        while (low < high && pivot <= nums[high])//从右向左找小于pivot的数
            high--;
        nums[low] = nums[high];//pivot是初始nums[low]的值,因此可以大胆赋值
        //赋值之后,nums[high]就相当于是空出来了,就可以让比pivot大的数移到右边
        while (low < high && pivot >= nums[low])
            low++;
        nums[high] = nums[low];
    }
    nums[low] = pivot;//最后还剩一个坑位,留给pivot的
    return low;//返回pivot的坑位
}
void quicksort(vector<int>& nums, int low, int high)
{
    if (low >= high) return;
    int k = partition(nums, low, high);
    quicksort(nums, low, k);
    quicksort(nums, k + 1, high);
}

int main()
{
    vector<int> nums(12);
    for (int i = 0; i < 9; i++)    cin >> nums[i];
    cout << "---------------" << endl;
    quicksort(nums, 0, 8);
    for (int i = 0; i < 9; i++) cout << nums[i] << endl;
    return 0;
}

```

## 复杂度分析

### 最好情况

![image-20200522101701746](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522101701746.png)

### 最坏情况

![image-20200522101709400](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522101709400.png)

### 平均情况

![image-20200522104140078](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522104140078.png)

![image-20200522104227522](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522104227522.png)

![image-20200522104239158](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522104239158.png)







## 排序问题的下界

如果一个问题的下界是$\Omega(n log n)$ 且算法的时间复杂性是$O(n log n)$, 那么这个算法是最优的。







# 动态规划之矩阵乘法

输入: $<A_1,A_2,...,A_n>,A_i$是矩阵

输出: 计算$A_1 \times A_2 \times,...,\times A_n$的最小代价方法



矩阵乘法的代价: 乘法的次数

eg: 若A是pxq的矩阵, B是qxr的矩阵, 则AxB的代价是O(pqr)

## 分析优化解的结构

![image-20200522115652456](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522115652456.png)

![image-20200522115703651](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522115703651.png)



![image-20200522120121421](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E8%AF%BE%E9%87%8C%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%9F%E8%AE%A1/image-20200522120121421.png)

## 递归方程

由上述结构可得到递归方程. 

**区间$i,j$乘法的最小代价**为**两个已经是最小代价的区间的代价和**加上**这两个矩阵相乘的代价**

其中, $p_{i-1}p_kp_j$是计算$A_{i~k} \times A_{k+1~j}$所需乘法数, 
$A_{i~ k}$和$A_{k+1 ~ j}$分别是$p_{i-1}\times p_k$和$p_k\times p_j$矩阵.

$m[i, j]= 0$,   $if(i=j)$
$m[i, j]= min_{i \le k<j}\{ m[i,k]+m[k+1,j]+p_{i-1} p_k p_j \}  $    $if(i<j)$



**一个小问题: 怎么知道$p_{i-1} p_k p_j $  ?**

## 自底向上地计算优化解的代价保存之, 并获取构造最优解的信息



 

## 根据构造最优解的信息构造优化解 