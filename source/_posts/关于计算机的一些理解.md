---
title: 关于计算机的一些理解
date: 2021-03-30 06:15:33
tags: 
	- 体系结构
categories: 
	- 学习
---

自己的话来描述计算机的发展。

<!--more-->

> 越来越觉得创造计算机以及在此基础上推动进一步发展的人真的很牛逼。能够在冰冷的机器上，赋予人类为其定义的意义，从而完成很多重复的、巨量的工作。

冯诺依曼提出的体系结构决定了未来几十年的计算机发展方向。

![冯诺依曼体系结构](http://c.biancheng.net/uploads/allimg/191108/2-19110Q1355B59.gif)

计算机将由五部分组成，运算器、存储器、控制器、输入、输出。根据这个指导思想，先将人们需要执行的指令存放在存储器中，控制器不断地取指令，通过分析，知道这种指令是什么含义后，就可以进行执行。

随着工艺的发展，机器能够计算的位数也逐渐变多。从16位到32位，到64位。位数越多，代表着人类能够赋予一条指令的含义越多，能够寻址的范围越大，代表着性能的上限能够更高。

人类在这些裸机上为其设计了指令集，指令集的作用实际上是把生硬的二进制串赋予了相应的含义。比如高四位是`1101`表示是加法，`1010`表示减法。在此基础上，我们就有了最基础的与机器交流的工具；或者说，我们有了建造高楼大厦的一粒沙子。

指令集又分为精简指令集和复杂指令集，这两者的区别是精简指令级将大部分情况下用不到的指令用几条简单的指令来实现。体现的规律即为二八定律：在生产生活中使用的最频繁的80%的操作，底层使用的只有百分之20%的指令。因此剩余的百分之80的指令就相当于是冗余的，可以使用更少的代价来表示同等语义的操作。

定义了这些指令集，就可以在抽象的机器上运行简单的程序。机器与指令集可以说是相辅相成的，机器可能并不支持指令集的部分指令；亦或者机器支持的功能大于指令集定义的功能。这也需要两者互相配合，芯片设计厂商会根据特定的指令集去设计出对应的芯片；有时也会根据特定的机器来设计特定的指令集。

但一直使用这样的 0101 串毕竟非常麻烦。因此出现了汇编，汇编一般来说是一对一的关系。将人能够看懂的一行代码转化成对应的一条机器代码。从而使人与机器的沟通不至于再那么麻烦。

但是对于很多人来说，使用汇编还是非常得困难。于是就出现了编译原理这门课（误）。编译技术的出现，使得人们可以滚雪球一样，逐渐扩大自己能够理解的范围。现在我们已经有了汇编语言，来对应指令集的128条指令（假设是128条）。我们可以用这128条汇编指令去构造一个更加复杂的语法，比如C语言。这里也没有说要用汇编语言来写所有的C语言文法，只需要写 C 语言文法的一小部分，我们就又可以通过已有的这些 C 语言文法来构造更大的文法集合。总之，这些操作都是为了人类能够更好地与机器沟通，能够将人理解的语言转换成机器能够执行的指令。机器并不知道人类给他赋予的这些语义，他只是不断地取指、分析、执行。

道生一，一生二，二生三，三生万物。语言能够表达的语义也越来越丰富，这也意味着执行人类的一条指令的时间也越来越长。这也是 C 语言快的原因，因为他简单。一条 C 指令只需要几条机器代码就可以表示，而表达能力丰富的语言则需要几十条甚至上百条。

但是，现在一个机器能够执行的程序只有一个。随着时间的推移，单道批处理系统难以满足人类的需求。于是操作系统出现了。

为了能够同时执行更多的程序，需要一个 base 程序去管理我们想做的作业。

人一多，事情就麻烦了。以前的机器只是一道程序的，现在机器变成了皇帝，而他妻妾成群，有着很多程序都想要皇帝的宠爱。那皇帝要怎么管理呢？

妾 A 想要皇帝，她就发了一个中断，让皇帝知道：诶，A 想他了，快去宠幸一下。

妾 B 在 A 完事之后，用了同样的操作来呼唤皇帝，但发现：诶？皇帝（CPU）心过来了，但是人（内存空间）咋还在 A 那里？？ 然后呢，皇帝就只能把妾 A 用过的东西留在原地，自己清清白白地去宠幸 B（切换上下文）。

但是妾 C 就不乐意了，她说俺也想！凭啥你们先？

皇帝轮了一轮下来，头都大了。要不每个人分你们一天，一天还不结束就换下一个人？自己这一身都七零八碎了，头被A用了，手被B用了，脚被C用了，乱的一批。

要不就渣一点，让她们都以为自己是在单独陪她们的，但实际上皇帝老海王了，同时在陪十几个甚至上百个人（虚拟内存）。

这里就出现了操作系统的经典几个问题，进程管理、内存管理以及没有提到的设备管理和文件管理。

但是还不够啊，皇帝一个人不够用。世界上有着很多很多皇帝，皇帝之间也会互相交流病情，交流一下御妻之道（？），于是计算机网络出现了。

有些老婆在存取速度、存取量的需求比较大，皇帝为了照顾到这些老婆，又只能搞个数据库来满足他们。一开始关系型数据库也够用了，但林子大了什么老婆都有，为了解决问题，又出了非关系型数据库。

但是还不够啊，老婆们的需求越来越多，全世界的皇帝联合起来啊。分布式计算、系统就出现了。一堆皇帝来满足同一个老婆，我就不信满足不了！

但是这又出现了问题，有的皇帝们之间沟通不畅啊，有的皇帝突然之间挂掉了。那只能牺牲一部分的性能来换取更高的可用性了。（CAP定理）分区容错性、可用性、一致性，不可能同时满足...


到现在，机器的0101010二进制串（沙子）变成了人类能够理解的，并且能够灵活运用的语言（砖头），人类又用这些砖盖出了一座座高楼大厦。很好不是吗？

但人类的需求是难以满足的，随着人工智能的爆发，需求也越来越多样化。原来盖出的高楼大厦虽然能满足部分需求，但人们也在寻找着性能更好的。

现在或许将是架构更替频繁的年代。是否有比冯诺依曼架构更加适合现在需求的架构呢，随着新型存储介质的出现，过去的架构是否符合现在的机器呢？