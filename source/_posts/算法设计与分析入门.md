---
title: 算法设计与分析入门
date: 2020-04-15 10:01:06
tags: [算法导论]
typora-root-url: ..
mathjax: true
---

大二学的算法设计

<!--more-->

#### 复习指导

动态规划之矩阵链乘法
注意讲义中的证明
贪心算法的证明什么的
搜索策略的后三节,人员安排问题,旅行商问题, A*算法
9.1比9.2重要
最重要的 345678章
其他的次重要

##### 第一章 绪论

##### 第二章 算法分析的数学基础

##### 第三章 排序与分治法

​	分治
​	归并
​	快排
​	排序问题的下界

##### 第四章 动态规划

##### 第五章 贪心算法

##### 第六章 搜索策略

##### 第七章 平摊分析

##### 第八章 图论算法

Bellman-Ford算法则是可以处理有负权值的有向图的最短路径问题。来判断该图中是否有负回路，或者存在最短路径的点。

  Dijkstra算法针对无负权值的图，求源点到某特定点的最短距离.

两者都用到了一个“松弛计算”的方法，也就是在遍历图的顶点和边的过程中修改距离数组的值，从而来找出最短路径。两个算法都是跟求图的有源最短路径有关。

##### 第九章 字符串匹配算法



#  算法概述

可以由一个给定计算模型机械地执行的**规则**或**计算步骤序列**称为该**计算模型的一个计算**

计算模型可以是图灵机, 也可以是其他的计算模型; 比如递归函数

一个计算机程序是一个计算 (计算模型是计算机)

计算可能永不停止——不是算法



## 当计算满足以下五个性质才能称为算法：

**有穷性**： 有限步内必须停止

**确定性**： 每一步都是严格定义和确定的动作

**能行性**： 每个动作都能被精确地机械执行

**输入**： 有一个满足给定约束条件的输入

**输出**： 满足给定约束条件的结果





## 问题的定义

问题定义了**输入和输出的关系**。



设input和output是两个集合；

问题是一个二元关系  $R\subseteq input\times output$

**input称为问题R的输入集合**, input的每个元素称为R的一个输入

**output称为问题R的输出或者结果集合**,output的每个元素称为R的一个结果



举例: 排序问题的定义如下

输入集合

 $input=\{<a_1,\dots ,a_n> |a_i是整数\}$

输出集合$output=\{<b_1,\dots ,b_n>|b_i是整数,b_1\leq\dots\leq b_n\}$

问题

$$ SORT=\{(<a_1,\dots,a_n>,<b_1,\dots,b_n>)|<a_1,\dots,a_n>\in Input,<b_1,\dots,b_n>\in Output,\{a_1,\dots,a_n\} = \{b_1, \dots,b_n\}\} $$



## 问题实例的定义

问题是一个二元关系,也是一个集合,每个元素都是一个二元组,**问题的实例**就是这个**集合中的二元组**。

需要注意的是 **一个算法面向一个问题，而不是仅求解一个问题的一个或者几个实例**

插入排序算法描述

```c
input: A[1,...,n] = n个数
output: A[1,...,n] = n个sorted数


For j=2 To n Do
	key<-A[j];
	i<-j-1;
	While i>0 And A[i]>Key Do
		A[i+1]<-A[i];//这个的意思是交换两个的位置
		i<-i-1;
	A[i+1]<-Key;
	
```



## 解决一个计算问题的过程

**可计算否?**

**能行可计算否?**  //比如要算150年,就不是能行可计算

**算法设计与分析**

**用计算机语言实现算法**

**软件系统**



可计算理论

计算复杂性理论

**算法设计和分析**

		- 可计算问题的算法的设计与分析

  - 设计算法的理论、方法和技术
  - 分析算法的理论、方法和技术

计算机软件







## 算法的正确性分析

**算法的正确性**

- 一个算法是正确的，如果它对于每一个输入都最终停止，而且产生正确的输出
- 不正确算法：
  - 不停止
  - 对所有输入都停止，但对某输入产生不正确结果
- 近似算法
  - 对所有输入都停止
  - 产生近似正确的解或产生不多的不正确解



**算法正确性证明**

- 证明算法对所有输入都停止
- 证明每个输入都产生正确结果
- 调试程序≠程序正确性证明；调试程序只能证明程序**有错**



## 算法复杂性分析的度量

目的：

- 预测算法对不同输入所需资源量

复杂性测度：

- 时间，空间，I/O等，是输入大小的函数

用途：

- 为求解一个问题选择最佳算法、最佳设备

### 输入的的大小

**设Input是问题R的输入集合，R的输入大小是一个函数**
$$
F: input->N, N是正整数集合
$$
**示例：** 

- **矩阵问题的输入大小=矩阵的维数** 

- **图论问题的输入大小=图的边数/结点数** 

### 时间复杂性

**一个算法对特定输入的时间复杂性是该算法对该输入产生结果需要的原子操作或“步”数**

注意：	

- 时间复杂性是输入大小的函数
- 我们假设每一步的执行需要常数时间，实际上每步需要的时间量可能不同

### 空间复杂性

**一个算法对特定输入的空间复杂性是该算法对该输入产生结果所需要的存储空间大小。** 





### 最坏复杂性

设**Input**是问题R的**输入集合**，**Complexity(X)**是**求解R的算法A**的复杂性函数，**Size(y)**是确定R中输入大小的函数，A的最坏复杂性是 
$$
Max\{Complexity(size(y))|y\in input\}
$$

### 最小复杂性

$$
Min\{Complexity(size(y))|y\in input\}
$$

### 平均复杂性

 设 $y\in Input$ ,y作为算法A的输入出现的概率是$p_y$，A的平均复杂性为
$$
\sum_{y\in input}p_y\times complexity(size(y))
$$




## 算法分析的模型

### 随机访问模型 //这门课涉及的

Random-Access-Model, RAM

- 单处理机,串行执行,无并发
- 基本数据类型
- 基本操作(每个操作常数时间)

### 并行多处理机模型(PRAM)





### 插入排序的分析例子



![image-20200226175143627](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200226175143627-1586927961331.png)

![image-20200226175920257](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200226175920257-1586927961331.png)





## 算法设计模式

- 暴力搜索
- 分治法
- 图搜索与枚举
  - 分支界限
  - 回溯
- 随机化方法

### 算法实现方法

- 递归与迭代
- 顺序、并行与分布式
- 确定性与非确定性
- 近似求解与精确求解
- 量子算法

### 最优化算法设计方法

- 线性规划
- 动态规划
- 贪心法
- 启发式方法



# 算法分析的数学基础

需要有一种更合适的方法来描述算法的效率

## 计算复杂性函数的阶



### 阶

- 描述增长率

- 忽略低阶项, 保留最高项

- 忽略常系数

  

  

- 利用$\Theta(n^2)$表示插入排序的最坏运行时间

- $\Theta(1)$,$\Theta(lg n)$,$\Theta(\sqrt n)$,$\Theta(n)$,$\Theta(nlgn)$,$\Theta(n^2)$,$\Theta(n^3)$,$\Theta(2^n)$,$\Theta(n!)$

- 增长的记号: $O$, $\Theta$,  $\Omega$   ,$o$,   $\omega$



### 同阶函数集合

![image-20200415132658987](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132658987.png)

$如果f(n)\in \Theta(g(n)), g(n)与f(n)同阶$

$f(n)\in \Theta(g(n))$,   记作 $f(n)=\Theta(g(n))$

![image-20200415132353720](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132353720.png)



- 通常$f(n)=an^2+bn+c=\Theta(n^2)$, 其中a,b,c是常数且a>0

- $p(n)=\sum_{i=0}^da_in^i$,其中$a_i$是常数且$a_d>0$ ——$p(n)=\Theta(n^d)$

- $\Theta(n^0)或者\Theta(1)$ 叫做常数时间复杂性

  

### 低阶函数集合

对于给定的函数g(n),

- ![image-20200415132714739](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132714739.png)
- 记作$f(n)\in O(g(n))或简记为f(n)= O(g(n))$

![image-20200228115628291](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200228115628291-1586927961331.png)





### 高阶函数集合

对于给定的函数g(n)

![image-20200415132724326](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132724326.png)

记作$f(n)\in \Omega (g(n))$,或简记为$$f(n)= \Omega (g(n))$$

![image-20200227123401632](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200227123401632-1586927961331.png)

#### 关于$\Omega$标记//下界

- 用来描述运行时间的最好情况
- 对所有输入都正确
- 比如, 对于插入排序
  - 最好运行时间是$\Omega(n)$ 
  - 或者说运行时间是$\Omega(n)$
  - 最坏运行时间是$\Omega(n^2)$
  - 但是说运行时间是$\Omega(n^2)$是错误的
- 可以用来描述问题
  - 排序问题的时间复杂性是$\Omega(n)$ 比如起码要比一遍才能知道是不是有序的



### 严格低阶函数

给定一个函数g(n),

![image-20200415132737982](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132737982.png)

![image-20200228115546674](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200228115546674-1586927961332.png)



#### 关于$o$标记 

$O$标记可能是紧或者不紧的

- $2n^2 = O(n^2)$是紧的,但$2n=O(n^2)$不是紧的

$o$标记用于标记上界,但不是紧的情况

- $2n=o(n^2)$,但是$2n^2\ne o(n^2)$

区别: 某个正常数c在O标记中, 但所有正常数c在o标记中
$$
f(n)=o(g(n))\Rightarrow \lim_{n\to \infty }\frac {f(n)}{g(n)}=0
$$
![image-20200415132147297](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132147297.png)

### 严格高阶函数

对于给定函数$g(n)$,

- $\omega(g(n))=\lbrace f(n):对于任意正常数c,存在正数n_0对于n\ge n_0,0\le cg(n)<f(n) \rbrace $
- 记作$f(n)\in \omega(g(n))$, 或者简记为$f(n)=\omega(g(n))$.

$\omega$标记, 类似 $o$标记, 表示不紧的下界

- $\frac {n^2}{2} = \omega (n)$但是$\frac {n^2}{2} \ne \omega (n^2)$



**$f(n)=\omega (g(n))$当且仅当$g(n)=o(f(n))$**



$  \lim _{n\to \infty} \frac {f(n)}{g(n)}=\infty$













###  $\Theta(g(n)) $和$O(g(n))$的关系

- $f(n)=\Theta(g(n)) \Rightarrow f(n)=O(g(n))$

- $\Theta$标记强于$O$标记, 因为$\Theta$是有上界和下界的,而$O$只有上界

- $\Theta(g(n)) \subseteq O(g(n))$

- $an^2+bn+c = \Theta(n^2)=O(n^2)$

- ### $an+b=O(n^2)$**//注意!!!**

- ### **$n=O(n^2)$//注意!!!**

- O标记表示渐进**上**界

- $\Theta$标记表示渐进**紧**界

- 如果$f(n)=O(n^k)$,则称f(n)是多项式界限的

一些讨论:

​	**当我们谈到插入排序的最坏运行时间是$O(n^2)$, 这个结论适用于所有的输入，即使对于已经排序的输入也成立，因为$O(n) \in O(n^2)$.**

**然而插入排序的最坏运行时间$\Theta(n^2)$不能应用到每个输入，因为对于已经排序的输入,  $\Theta(n) \ne \Theta(n^2)$**









###  $O,\Theta,\Omega$标记的关系



**对于f(n)和g(n), f(n)=$\Theta(g(n))$当且仅当$f(n)=O(g(n))$且$f(n)=\Omega(g(n))$**

- $O$: 渐进上界
- $\Theta$: 渐进紧界
- $\Omega$: 渐进下界





### 渐进符号的性质

- 传递性: 所有五个标记
  - $f(n) = \Theta(g(n))且g(n)=\Theta(h(n)) \Rightarrow f(n)=\Theta(h(n))$
- 自反性: $O,\Theta,\Omega$
  - $f(n)=\Theta(f(n))$
- 对称性:$\Theta$
  - $f(n)=\Theta(g(n))当且仅当g(n)=\Theta(f(n))$
- 反对称性:
  - $f(n)=O(g(n))当且仅当g(n)=\Omega(f(n))$
  - $f(n)=o(g(n))当且仅当g(n)=\omega(f(n))$



## 和式的估计与界限

#### 线性和

#### 级数

![image-20200310112512197](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200310112512197-1586927961332.png)

![image-20200310112528467](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200310112528467-1586927961332.png)

#### 和的界限

#### 直接求和的界限

例1

![image-20200415132522231](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132522231.png)

例2

![image-20200415132537465](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132537465.png)

例3

![image-20200307103022808](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307103022808-1586927961332.png)

![image-20200415132244946](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200415132244946.png)



![image-20200307103103445](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307103103445-1586927961332.png)



![image-20200307103120898](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307103120898-1586927961332.png)





![image-20200307103134824](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307103134824-1586927961332.png)





![ ](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307103217332-1586927961332.png)

![image-20200307103227460](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307103227460-1586927961332.png)

### 递归方程

**递归方程:** **递归方程是使用小的输入值来描述一个函数的方程或不等式**

1. 替换方法

- 联想已知的T(n)

- 猜测上下界,减少不确定性
- 细微差别的处理

猜测正确, 数学归纳法的归纳步骤似乎证不出来:  减去一个或几个低阶项可能有用

- 变量替换方法

经过变量替换把递归方程变换为熟悉的方程

2. 迭代方法**

**方法：** 

**循环地展开递归方程，** 

**把递归方程转化为和式，** 

**然后可使用求和技术解之**

3. **Master方法**

![image-20200307104612056](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307104612056-1586927961332.png)

![image-20200307104635405](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307104635405-1586927961332.png)

![image-20200307104646883](/images/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/image-20200307104646883-1586927961332.png)

# 动态规划

分治的问题: 

​	如果子问题不是独立的, 那么分治方法将重复计算公共子问题,效率很低



动态规划的特点:

- 把原始问题划分成一系列子问题
- 求解每个子问题仅一次,并将其结果保存在一个表中,以后用到时直接存取,不重复计算,节省计算时间
- 自底向上地计算



适用范围:

- 一类优化问题: 可分为多个相关子问题,子问题的解被重复使用



使用条件:

- 优化子结构
  - 当一个问题的优化解包含了子问题的优化解时,我们说这个问题具有优化子结构
  - 缩小子问题合集, 只需那些优化问题中包含你的子问题, 降低实现复杂性
  - 优化子结构使得我们能自下而上地完成求解过程
- 重叠子问题
  - 在问题的求解过程中,很多子问题的解将被多次使用





动态规划算法的设计步骤: 

- 分析优化解的结构

- 递归地定义最优解的代价

- 自底向上地计算优化解的代价保存之，并获取构造最优解的信息

- 根据构造最优解的信息构造优化





## 最优二叉搜索树



# 背包问题

## 0/1背包问题

### 问题描述: 

**有N件物品和一个容量为V的背包。第i件物品的费用（即体积，下同）是w[i]，价值是val[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。**

### 解题思路: 

阶段——物品的件数

状态——背包剩下的容量

f [i,v]设为从前i件物品中选择放入容量为v的背包的最大的价值

```C
K[x,0] = 0 for all x=0,...,W
K[0,i] = 0 for all i=0,...,n
Result[p] = 0 for all p=0,...,n

for x = 1,...,W
    for j = 1,...,n:
		K[x,j] = K[x,j-1]
         if Wj <= x:
			K[x,j] = max{K[x,j],K[x-wi,j-1]+vj}
			if K[x,j]== K[x-wi,j-1]+vj
                Result[j] = 1
return K[W,n]
    
```



只考虑子问题: 

将前i个物品放入容量为v的背包中的最大价值, 那么就变成考虑两个问题, 第一个: 如果不放入i,那么最大价值就和i无关, 就是f [i-1]\[ v] ; 第二个: 如果放入, 价值就是f [i-1]\[v-w[i]]+val[i], 取这两者的最大值即可。

$f[i][v]=max\{f[i-1][v],f[i-1][v-w[i]]+val[i]\}$

空间优化：

上述状态表示，我们需要用二维数组，但事实上我们只需要一维的滚动数组就可以递推出最终答案。考虑到用f[ v ]来保存每层递归的值，由于我们求f[ i ][ v ] 的时候需要用到的是f[ i-1 ][ v] 和 f[ i-1 ][v - w[i] ] 于是可以知道，只要我们在求f[ v ]时不覆盖f[ v - w[i] ]，那么就可以不断递推至所求答案。所以我们采取倒序循环，即v = m（m为背包总容积）伪代码如下：

```c
　for i = 1..N

　　　for v = V..0

　　　　　f[v]=max{f[v],f[v-w[i]]+val[i]};
```



## 完全背包问题

###  **问题描述：**

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w[i]，价值是val[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

## 解题思路

完全背包问题与0/1背包问题不同之处在于其每个物品是无限的，从每种物品的角度考虑，与它相关的策略就变成了取0件、1件、2件...。我们可以根据0/1背包的思路，对状态转移方程进行改进，令**f[i][v]表示前 i 种物品恰放入一个容量为 v 的背包的最大权值**。状态转移方程就变成了：

$ f[i][v]=max\lbrace f[i-1][v-k*w[i]]+k*val[i]|0<= k*w[i] <= v \rbrace$

我们通过对0/1背包的思路加以改进，就得到了完全背包的一种解法，这种解法时间复杂度为O（n^3） ，空间复杂度为O（n^2）。

## 时间优化

​		根据上述f[ i ][ v ]的定义，其为前 i 种物品恰好放入容量为 v 的背包的最大权值。根据上述状态转移方程可知，我们假设的是**子结果$f[i-1][v-k*w[i]]$中并没有选入第 i 种物品**，所以我们需要逆序遍历（像0/1背包一样）来确保该前提；但是我们现在考虑“加选一件第 i 种物品”这种策略时，正**需要一个可能已经选入第 i 种物品的子结果**$f[ i ][ v-w[i] ]$，于是当我们**顺序遍历**时，就刚好达到该要求。这种做法，使我们省去了一层循环，即第 i 种物品放入的件数k，从而时间复杂度优化为O（n^2）。


## 空间优化

正如0/1背包的空间优化，上述状态转移方程已经优化为：

$ f[i][v]=max\{f[i-1][v],f[i][v-w[i]]+val[i]\}$

将这个方程用一维数组实现，便得到了如下伪代码：

```
for i = 1..N

　　　for v = 0..V

　　　　 f[v] = max{f[v],f[v-w[i]] + val[ i ] };
```

## 小剪枝

完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足w[i] <= w[j]且val[i] >= val[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。



## 转化为0/1背包问题

​	既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/w[i]件，于是可以把第i种物品转化为V/w[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。

​	更高效的转化方法是：把第i种物品拆成费用为w[i]*2^k、价值为val[i]*2^k的若干件物品， 其中k满足w[i]*2^k<V 。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/w[i])+1)件物品，是一个很大的改进。


# 贪心算法

## 活动选择问题

​	假设有n个活动的集合$S=\{a_1,a_2,...,a_n\}$,这些活动使用同一个资源, 而这个资源在某个时刻只能供一个活动使用。每个活动$a_i$ 都有一个开始时间$s_i$和一个结束时间$f_i$, 其中$0<=s_i<f_i<\infty$. 如果被选中, 任务$a_i$发生在半开时间区间$[s_i,f_i)$期间。如果两个活动$a_i$和$a_j$满足$[s_i,f_i)$和$[s_j,f_j)$不重叠，则称它们是兼容的。也就说，若$s_i>=f_j$或sj>=fi，则$a_i$和$a_j$是兼容的。在活动选择问题中，我们希望选出一个最大兼容活动集。假定活动已按结束时间$f_i$的单调递增顺序排序：
$ f1<=f2<=f3<=f4<=...<=fn-1<=fn$





### 活动选择问题的最优子结构

设$S_{ij}$表示在$a_i$结束之后开始, 且在$a_j$开始之前结束的那些**活动的集合**

假定我们希望求$S_{ij}$的一个最大相互兼容的活动子集, 假设$A_{ij}$就是这样一个子集, 包含活动$a_k$

那么可以将$A_{ij}$分解为：$A_{ij} = A_{ik}+a_{k}+A_{kj}$。假设Cij为Aij的大小，那么有$C_{ij}=C_{ik}+C_{kj}+1$。



用剪切-粘贴法证明最优解$A_0$必然包含两个子问题$S_{ik}和S_{kj}$的最优解. 否则, 如果可以找到$S_{kj}$的一个兼容活动子集$A^{'}_{kj}$, 满足$|A^{'}_{kj}|>|A_{kj}|$, 则可以将A^{'}_{kj}作为S_{ij}的最优解的部分, 这样就构造出一个兼容活动集, 其大小|

## 哈夫曼编码

## 最小生成树

## 单源最短路径



