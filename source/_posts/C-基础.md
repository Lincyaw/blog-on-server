---
title: C++基础
date: 2019-08-21 17:05:56
tags: C++笔记
---
xixixi

<!--more-->

# 命名空间

namespace 命名空间名{
各种声明(函数声明、类声明、...）
}

例如:


```
namespace ns{
int fun1();
float fun2();
int num;
}
```


在其他命名空间引用该命名空间声明的标识符需采用:


```
命名空间名::标识符名
```


如:


```
ns::num;
```


还允许嵌套使用命名空间,例如:


```
namespace n1{
	namespace n2{
		int count;
		}
}
```

可以通过

```
n1::n2::count
```

引用count;

# 基本数据类型

|类型名   |长度(字节)   |取值范围|
| ------- |:-----------:|:------:|
|bool|1|false,true|
|char |1|-128~127|
|signed char|1|-128~127|
|unsigned char|1|0~255|
|short(signed short)|2|-32768~32767|
|unsigned short|2|0~65535|
|int(signed int)|4|-2147483648~2147483647|
|unsigned int|4|0~4294967295|
|long(signed long)|4|-2147483648~2147483647|
|unsigned long|4|0~4294967295|
|float|4|3.4 * 10^-38~3.4 * 10^38|
|double|8|1.7 * 10^-308~1.7 * 10^308|
|long double|8|1.7 * 10^-308~1.7 * 10^308|

# 非基本数据类型

主要包括: 枚举类型,结构体类型,联合体类型,数组类型,指针类型,类类型

## 枚举类型

enum 枚举类型名 {变量值列表};
例如: 一场比赛的结果有胜,负,平局和取消四种,可以通过这种方式声明:

```
enum game{win,lose,tie,cancel};
```

枚举类型应用说明:
1. 对枚举元素按常量处理, 不能对他们赋值. eg: 不能写: win = 0;
2. 枚举元素具有默认值, 他们依次为:0,1,2,3...
3. 也可以在声明时另行指定枚举元素的值,如:
```
enum game{win=3, lose, tie= 0, cancel};
```
4. 枚举值可以进行关系运算
5. 整数值不能直接赋给枚举变量, 如需要将整数赋值给枚举变量,应进行强制类型转换

## 数组类型

数组是具有一定顺序关系的若干相同类型变量的集合体, 组成数组的变量称为该数组的元素

## 结构体类型

由不同的数据类型构成的一种混合的数据结构, 构成结构体的成员的数据类型一般不同, 并且在内存中分别占据不同的储存单元

## 联合体类型

联合体类型类似于结构体的一种构造类型, 与结构体不同的是构成联合体的数据成员共用一段内存单元

## 指针类型

指针类型变量用于储存另一变量的地址, 而不能用来存放基本类型的数据. 他在内存中占据一个储存单元

##  类类型

类是一个数据类型, 他定义的是一种对象类型, 由数据和方法组成, 描述了属于该类型的所有对象的性质

# 关系运算符和关系表达式

关系运算是非常简单的一种运算形式, 关系运算符及其优先次序如下:

<	<=	>	>=	==	!=

前4个优先级相同;后2个优先级相同, 但小于前四个优先级  
用关系运算符将两个表达式连接起来就构成了关系表达式. 关系表达式的结果为布尔型, 值为true或false. 关系运算符的优先级低于算术运算符, 高于复制运算符

例如: 

```
c < a-b 等价于 c < (a-b)
a > b != c 等价于 (a>b) != c
a == b > c 等价于 a == (b>c)
a = b >= c 等价于 a = (b >= c)
```

# const 关键字

在C++中, const关键字的主要用途如下:

```
常变量: const类型说明符变量名;
常引用: const类型说明符&引用名;
常对象: 类名 const 对象名;
常成员函数: 类名::函数名(形参) const;
常数组: 类型说明符 const 数组名[大小];
常指针: cosnt 类型说明符* 指针名, 类型说明符 * const指针名
```
在常变量(cosnt 类型说明符变量名)、 常引用（const 类型说明符&引用名）、 常对象（类名 const 对象名）、 常数组（类型说明符 const 数组名[大小]）中， const与“类型说明符”或“类名”的位置可以互换。

## 用法一: 常变量
类似于C中的宏定义，在声明时必须进行初始化。 const限制了常量的使用方式， 常变量在使用前一定要声明。 例如, 可以声明一件商品的价格为:  
const float price = 3.2;
  常变量在声明之前一定要赋值, 并且在程序中不能改变其值.
## 用法二: 常指针(指针和常量)
常指针包含两种形式: 一种是指向常量的指针; 另一种是指针类型的常量. 指向常量的指针不能通过指针来改变所指对象的值, 但指针本身可以改变, 可以指向另外的对象. 指针类型的常量中指针本身的值不能改变.  
在常指针的使用时涉及两个对象: 指针本身和被它所指的对象. 将一个指针的声明用const"预先固定"将使那个对象而不是使这个指针成为常量(指向常量的指针). 要将指针本身而不是被指对象声明为常量, 必须使用声明运算符_* const_ (指针类型的常量). 所以出现在 * 之前的const是作为数据类型的一部分:

```
char *const p; // 到char的const指针,指针类型的常量
char const *p1;// 到const char的指针,指向常量的指针
const char *p2;// 到const char的指针(后面两种声明是等价的)
```

这个地方比较容易混淆, 再距离说明
例如:

```
const int * m1 = new int(10);
int * const m2 = new int(20);
```

在上面的两个表达式中, 最容易让人迷惑的是const到底是修饰指针还是指针指向的内存区域? 其实, 只要知道: const只对它左边的量起作用, 唯一的例外就是const本身就是最左边的修饰符,那么它才会对右边的量起作用. 根据这个规则来判断, m1应该是常量指针(即不能通过m1来修改他所指向的内容),而m2应该是指针常量(即不能让m2指向其他的内存模块). 由此可见:

(1) 对于常量指针, 不能通过该指针来改变所指的内容. 即下面的操作是错误的:

```
int i = 1;
const int *pi = &i;
*pi = 10;
```

此处错在你试图通过pi改变它所指向的内容. 但是, 并不是说该内存块中的内容不能被修改, 我们仍可以通过其他方式去修改其中的值. 例如:

```
//1: 通过i直接修改
i = 10;
//2: 使用另外一个指针修改
int *p = (int *pi);
*p = 10;
```

实际上, 在将程序载入内存的时候, 会有专门的一块内存区域来存放常量. 但是, 上面的i本身不是常量, 是存放在栈或堆当中的, 仍然可以修改他的值. 而pi不能修改指向的值应该说是编译器的一个限制

(2) 根据上面const的规则, 
```
const int *m1 = new int(10);
```
 也可写作:
```
int const *m1 =  new int (10);
```

(3) 在函数参数中使用指针常量时表示不允许将该指针指向其他内容.

```
void func_02(int *const p)
{
	int *pi = new int (100); 
	//错误, p是指针常量. 不能对它赋值.
	p = pi;
}
int main()
{
	 int *p = new int(10);
	 func_02(p);
	 delete p;
	 return 0;
}
```

(4) 在函数参数中使用常量指针时表示在函数中不能改变指针所指向的内容

```
void func(const int *pi)
{
	//错误, 不能通过pi去改变pi所指向的内容;
	*pi = 100;
}
int main()
{
	int *p = new int (10);
	func(p);
	delete p;
	return 0;
}
```

可以使用这样的方法来防止函数调用者改变参数的值, 但是, 这样的限制是有限的, 作为参数调用者, 不要试图去改变参数中的值.

## 用法三: 常函数
----常函数是C++对常量的一个扩展, 它很好地确保了C++中类的封装性. 在C++中, 为了防止类的数据成员被非法访问, 将类的成员函数分成了两类: 一类是常成员函数;另一类是非常成员函数. 在一个函数名后面加上关键字const后该函数就成了常函数. 对于常函数, 最关键的不同是编译器不允许其修改类的数据成员.例如:
```
class Test
{
public:
	void f() const;
private:
	int i;
};
void Test::f() const{
	i = 100;
}
```
在上面的代码中, 常函数f试图去改变数据成员i 的值, 因此将在编译的时候引发异常.  
当然, 对于非常成员函数, 可以根据需要读取或修改数据成员的值. 但是, 这要依赖调用函数的对象是否为常量. 通常, 如果把一个类定义为常量, 目的是希望其状态(数据成员)不会被改变, 那么, 如果一个常对象调用它的非常成员函数会产生什么后果呢?看下面的代码:

```
class T
{
public: 
	void f1() const;
	void f2();
};
void TestCode(T& change,const T& unChange)
{
	change.f1(); //正确, 非常对象可以调用常函数
	change.f2(); //正确, 非常对象也允许调用非常成员函数修改数据成员
	unChange.f1(); //正确, 常对象只能调用常成员函数, 因为不希望修改对象状态
	unChange.f2(); //错误, 常对象的状态不能被修改, 而非常成员函数存在修改对象状态的可能
}
```

从上面的代码可以看出: 由于常对象的状态不允许被修改, 因此, 通过常对象调用非常成员函数时将会产生语法错误.

## 用法四: 常引用(常量与引用)

常量与引用的关系比较简单. 因为引用就是另一个变量的别名, 它本身就是一个常量. 也就是说不能再让一个引用成为另外一个变量的别名, 那么他们只剩下其代表的内存区域是否可变. 即:

```
int i = 10;
// 表示不能通过该引用去修改对应的内存的内容
const int &ri = i;
// 错误, 写法不对
int& const ri = i;
```

由此可见, 如果不希望函数的调用者改变参数的值, 最可靠的方法应该是使用引用/ 下面的操作会存在编译错误;

```
void f(const int&ri)
{
// 错误!不能通过常引用ri去改变它所代表的内存区域
	ri = 5;
}
int main()
{
int i =1;
f(i);
return 0;
}
```

## 用法五: 常对象 (const 对象)

const对象只能访问const成员函数, 而非const对象可以访问任意的成员函数, 包括const成员函数;  
const对象的成员是不能修改的, 而通过指针维护的对象可以修改.  
const成员函数不可以修改对象的数据, 不管对象是否具有const性质, 编译时以是否修改成员数据为依据进行检查  


# 构造函数带默认值
要保证所有的默认参数均放在参数表的最后, 即默认参数值必须按从右向左的顺序声明.
eg:  
```
void func(int x, int n1 = 1, int n2 = 2);//正确
int add(int x, int y = 5, int z = 6);//正确
int add(int x = 1,int y = 5, int z);//错误
int add(int x = 1, int y, int z = 6);//错误
```

# 析构函数
析构函数是一种用于撤销对象,回收对象占有资源的特殊成员函数, 它与构造函数
	功能互补, 成对出现. 如果在类中未显式定义析构函数, 系统会自动调用一个默认
	析构函数,该函数无参数, 函数体为空
1. 无返回类型,但是不要加void
2. 无参数, 因此不存在析构函数重载, 只有一个析构函数
3. 在对象释放时由系统自动调用
4. 如果程序中未声明, 则系统自动产生一个默认析构函数
5. 析构函数与构造函数的功能相对应, 所以析构函数名是构造函数名前加一个逻辑反运算符”~”
6. 析构函数按照与调用构造函数相反的顺序被调用

必须定义析构函数的情况如下:
1. 构造函数打开一个文件, 使用完文件时需要关闭文件
2. 从堆中分配了动态内存区, 在对象消失之前必须释放

# 静态成员
用static修饰(类似全局变量)的成员,使用静态成员比使用全局变量更为优越不属于某个对象, 不能通过某个对象来引用, 在声明时前面要加上static关键字,称为*静态成员*. 静态成员由同类的所有对象共享. 也就是说不管定义了多少个对象,其静态成员只有一个. 并且静态成员的生命周期从创建开始到程序运行结束, 编译器只对它进行一次初始化, 将始终保持其值,直到下次改变为止. 静态成员不受对象是否创建的影响.  

静态数据成员是同类的所有对象共享的成员, 而不是某一对象独有的成员, 它的值对每个对象都是一样的. 对静态数据成员的值的更新,即是对所有对象的该静态数据成员值的更新   

要使用静态数据成员, 必须要main程序运行前分配空间和初始化. 静态成员不与类的任何特定对象相关联.静态数据成员初始化必须在类的外部进行, 与一般数据成员初始化不同,格式如下:

```
	<数据类型><类名>::<静态数据成员名>=<值>
	int circle::total = 0;
```

静态数据成员可被该类的静态成员函数使用, 也可被该类的普通成员函数使用 	而静态成员函数只能引用属于该类的静态数据成员和静态成员函数
	
# 友元函数:
在类声明中由关键字friend修饰说明的非成员函数, 在它的函数体中能够通过对象名访问private和protected成员. 在友元函数中, 必须通过对象名访问对象中的成员.一个函数可以是多个类的友元函数,需要在各个类中分别声明, 并且有元关系不具有传递性

## 友元成员函数:
若一个类的成员函数是另一个类的友元, 则称该成员为另一个类的友元成员函数
友元成员函数声明语法:
将某个类的成员函数在另一个类中使用friend修饰说明,并且加上友元函数所在的类名
## 友元类:
友元类是指若一个类为另一个类的友元, 则前一个类的所有成员都能访问后一个类的私有或保护成员, 从这个角度看, 有友元类的所有成员函数都是另一个类的友元成员函数
### 声明语法:
将友元类名在另一个类中使用friend修饰说明
共享成员的保护  
用const 定义不能改变的对象

# 赋值兼容规则
所谓赋值兼容规则(向上转型)是 指一个公有派生类的对象在使用上可以被当作基类的对象, 反之则禁止. 具体表现在:

1.	派生类的对象可以被赋值给基类对象
2.	派生类的对象可以初始化基类的引用
3.	指向基类的指针也可以指向派生类, 即一个公有派生类对象的指针值可以赋值给(或初始化)一个基类指针.
4.	利用这样的指针或引用, 只能访问派生类对象中从基类继承过来的成员, 无法访问派生了的自有成员. 这又称为里氏代换原则. 子类的对象可以赋值给父类, 也就是子类对象可以向上转型为父类类型. 向上转型是安全的
eg: 

```
circle c1(100,100,10);//派生类 ,里面有show函数, 打印其基类point里的数据
point p1=c1,*p2=&c1,&p3=c1;
p1.show();
p2->show();
p3.show(); //都可以运行
```

# 虚函数
当派生类从多个基类派生,而这些基类又从同一个基类派生时,则在访问此共同积累中
的成员时, 将产生二义性

		虚基类用于有共同基类的场合
		虚基类在声明时以virtual修饰说明基类, 例如:
```
	class B1:virtual public B
```
其作用是解决多继承问题时可能发生的对同一基类继承多次而产生的二义性问题,为最远的派生类提供唯一的基类成员, 而不重复产生多份备份
	
虚函数是动态联编的基础. 要使用虚函数, 只要在类的声明中在函数原型之前写virtual即可
虚函数调用方式是通过基类指针或引用, 执行时会根据指针指向的对象的类决定调用哪个函数.如果是通过基类对象调用与函数, 也不适合动态联编
注意:
1. virtual只用来说明类声明中的原型, 不能用在函数实现时.
2. 虚函数具有继承性, 基类中声明了虚函数,派生类中无论是否说明, 同一原型函数都自动成为虚函数.
3. 虚函数的本质不是重载声明, 而是覆盖
4. 虚函数是非静态的成员函数

采用动态联编, 则随p指向的对象不同, 使p->print()能调用不同类中的print版本, 这样就可以用一个界面p->print()访问多个实现版本, 该函数调用依赖于运行时p所指向的对象,具有多态性.
继承是动态联编的前提, 虚函数是动态联编的基础

## 抽象类与纯虚函数
所谓抽象类是指带有纯虚函数的类, 抽象类的定义形式如下:
```
class 类名
{
virtual 类型 函数名(参数表)=0;
......
}
```
抽象类的作用如下:
```
(1)抽象类是为抽象和设计的目的而建立的, 将有关的数据和行为组织在一个继承层次结构中, 保证派生类具有要求的行为
(2)对于暂时无法实现的函数, 可以声明为纯虚函数, 留给派生类去实现
```
注意:
```
(1)抽象类只能给你作为基类来使用
(2)不能声明抽象类的对象
(3)构造函数不能是虚函数, 析构函数可以使虚函数
```